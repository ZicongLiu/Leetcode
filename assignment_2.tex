%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Programming/Coding Assignment
% LaTeX Template
%
% This template has been downloaded from:
% http://www.latextemplates.com
%
% Original author:
% Ted Pavlic (http://www.tedpavlic.com)
%
% Note:
% The \lipsum[#] commands throughout this template generate dummy text
% to fill the template out. These commands should all be removed when
% writing assignment content.
%
% This template uses a Perl script as an example snippet of code, most other
% languages are also usable. Configure them in the "CODE INCLUSION
% CONFIGURATION" section.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage{fancyhdr} % Required for custom headers
\usepackage{lastpage} % Required to determine the last page for the footer
\usepackage{extramarks} % Required for headers and footers
\usepackage[usenames,dvipsnames]{color} % Required for custom colors
\usepackage{graphicx} % Required to insert images
\usepackage{listings} % Required for insertion of code
\usepackage{courier} % Required for the courier font
\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template
\usepackage{bm} % Used for bold font in $$ Math mode
\usepackage{animate}
\usepackage{url}

% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1} % Line spacing

% Set up the header and footer
\pagestyle{fancy}
\lhead{\hmwkAuthorName} % Top left header
\chead{\hmwkClass\ : \hmwkTitle} % Top center head
\rhead{\firstxmark} % Top right header
\lfoot{\lastxmark} % Bottom left footer
\cfoot{} % Bottom center footer
\rfoot{Page\ \thepage\ of\ \protect\pageref{LastPage}} % Bottom right footer
\renewcommand\headrulewidth{0.4pt} % Size of the header rule
\renewcommand\footrulewidth{0.4pt} % Size of the footer rule

\setlength\parindent{0pt} % Removes all indentation from paragraphs

%----------------------------------------------------------------------------------------
%	CODE INCLUSION CONFIGURATION
%----------------------------------------------------------------------------------------

\definecolor{MyDarkGreen}{rgb}{0.0,0.4,0.0} % This is the color used for comments
\lstloadlanguages{Perl} % Load Perl syntax for listings, for a list of other languages supported see: ftp://ftp.tex.ac.uk/tex-archive/macros/latex/contrib/listings/listings.pdf
\lstset{language=java, % Use Perl in this example
        frame=single, % Single frame around code
        basicstyle=\small\ttfamily, % Use small true type font
        keywordstyle=[1]\color{Blue}\bf, % Perl functions bold and blue
        keywordstyle=[2]\color{Purple}, % Perl function arguments purple
        keywordstyle=[3]\color{Blue}\underbar, % Custom functions underlined and blue
        identifierstyle=, % Nothing special about identifiers
        commentstyle=\usefont{T1}{pcr}{m}{sl}\color{MyDarkGreen}\small, % Comments small dark green courier font
        stringstyle=\color{Purple}, % Strings are purple
        showstringspaces=false, % Don't put marks in string spaces
        tabsize=5, % 5 spaces per tab
        %
        % Put standard Perl functions not included in the default language here
        morekeywords={rand},
        %
        % Put Perl function parameters here
        morekeywords=[2]{on, off, interp},
        %
        % Put user defined functions here
        morekeywords=[3]{test},
       	%
        morecomment=[l][\color{Blue}]{...}, % Line continuation (...) like blue comment
        numbers=left, % Line numbers on left
        firstnumber=1, % Line numbers start with line 1
        numberstyle=\tiny\color{Blue}, % Line numbers are blue and small
        stepnumber=5 % Line numbers go in steps of 5
}

% Creates a new command to include a perl script, the first parameter is the filename of the script (without .pl), the second parameter is the caption
\newcommand{\perlscript}[2]{
\begin{itemize}
\item[]\lstinputlisting[language=perl, caption=#2,label=#1]{#1.pl}
\end{itemize}
}

% Creates a new command to include a Java source file, the first parameter is the filename of the script (without .java), the second parameter is the caption
\newcommand{\javacode}[2]{
\begin{itemize}
\item[]\lstinputlisting[language=java, caption=#2,label=#1,basicstyle=\small]{answers/#1.java}
\end{itemize}
}

% Creates a new command to include a C source file, the first parameter is the filename of the script (without .c), the second parameter is the caption
\newcommand{\ccode}[2]{
\begin{itemize}
\item[]\lstinputlisting[language=c, caption=#2,label=#1,basicstyle=\small]{answers/#1.c}
\end{itemize}
}

%----------------------------------------------------------------------------------------
%	DOCUMENT STRUCTURE COMMANDS
%	Skip this unless you know what you're doing
%----------------------------------------------------------------------------------------

% Header and footer for when a page split occurs within a problem environment
\newcommand{\enterProblemHeader}[1]{
\nobreak\extramarks{#1}{#1 continued on next page\ldots}\nobreak
\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
}

% Header and footer for when a page split occurs between problem environments
\newcommand{\exitProblemHeader}[1]{
\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
\nobreak\extramarks{#1}{}\nobreak
}

\setcounter{secnumdepth}{0} % Removes default section numbers
\newcounter{homeworkProblemCounter} % Creates a counter to keep track of the number of problems

\newcommand{\homeworkProblemName}{}
\newenvironment{homeworkProblem}[1][Problem \arabic{homeworkProblemCounter}]{ % Makes a new environment called homeworkProblem which takes 1 argument (custom name) but the default is "Problem #"
\stepcounter{homeworkProblemCounter} % Increase counter for number of problems
\renewcommand{\homeworkProblemName}{#1} % Assign \homeworkProblemName the name of the problem
\section{\homeworkProblemName} % Make a section in the document with the custom problem count
\enterProblemHeader{\homeworkProblemName} % Header and footer within the environment
}{
\exitProblemHeader{\homeworkProblemName} % Header and footer after the environment
}

\newcommand{\problemAnswer}[1]{ % Defines the problem answer command with the content as the only argument
\noindent\framebox[\columnwidth][c]{\begin{minipage}{0.98\columnwidth}#1\end{minipage}} % Makes the box around the problem answer and puts the content inside
}

\newcommand{\homeworkSectionName}{}
\newenvironment{homeworkSection}[1]{ % New environment for sections within homework problems, takes 1 argument - the name of the section
\renewcommand{\homeworkSectionName}{#1} % Assign \homeworkSectionName to the name of the section from the environment argument
\subsection{\homeworkSectionName} % Make a subsection with the custom name of the subsection
\enterProblemHeader{\homeworkProblemName\ [\homeworkSectionName]} % Header and footer within the environment
}{
\enterProblemHeader{\homeworkProblemName} % Header and footer after the environment
}

%----------------------------------------------------------------------------------------
%	Problem Description
%----------------------------------------------------------------------------------------
\newcommand{\desc}[1]{
\begin{lstlisting}
    #1
\end{lstlisting}
}

%----------------------------------------------------------------------------------------
%	Problem Title
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
%	NAME AND CLASS SECTION
%----------------------------------------------------------------------------------------

\newcommand{\hmwkTitle}{Record} % Assignment title
\newcommand{\hmwkDueDate}{Tuesday,\ February\ 23,\ 2016} % Due date
\newcommand{\hmwkClass}{Leetcode} % Course/class
\newcommand{\hmwkClassTime}{10:30am} % Class/lecture time
\newcommand{\hmwkClassInstructor}{Jones} % Teacher/lecturer
\newcommand{\hmwkAuthorName}{Johnny Liu} % Your name

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title{
\vspace{2in}
\textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
\normalsize\vspace{0.1in}\small{Start\ from\ \hmwkDueDate}\\
\vspace{3in}
}

\author{\textbf{\hmwkAuthorName}}
\date{} % Insert date here if you want it to appear below your name

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle

%----------------------------------------------------------------------------------------
%	TABLE OF CONTENTS
%----------------------------------------------------------------------------------------

%\setcounter{tocdepth}{1} % Uncomment this line if you don't want subsections listed in the ToC

\newpage
\tableofcontents
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 234 Palindrome Linked List
%----------------------------------------------------------------------------------------

% To have just one problem per page, simply put a \clearpage after each problem

\begin{homeworkProblem}
\title{\textbf{\large Problem 234 Palindrome Linked List}}




\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
   Given a singly linked list, determine if it is a palindrome.

    Follow up:
    Could you do it in O(n) time and O(1) space?

    https://leetcode.com/problems/palindrome-linked-list/

\end{lstlisting}

\textbf{Solution 1}

  ~~Listing \ref{Pro234_1} shows solution with $\bm{O(n) runtime, O(n) space}$.\\

  ~~The key idea is to use a stack storing elements from List, where popping elements out from a stack is exactly reversing the List.(The stack may use $O(n) space$.)


\javacode{Pro234_1}{Thought 1}



\textbf{Solution 2}

Listing \ref{Pro234_2} shows Solution 2 with $\bm{O(n) runtime, O(n) space}$. \\

Instead of using stack, this solution finds element in the middle of whole List, reverse the second half and compare the elements with those in the first half.

Some key ideas:
    \begin{enumerate}
        \item The key idea of getting the middle element is to keep two iteration pointers, one with 1 step while another with 2 steps every time they iterate.
        \item Take care of how to reverse a Linked-list in-place.
    \end{enumerate}
\javacode{Pro234_2}{Thought2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 35 Search Insert Position
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large Problem 35 Search Insert Position}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given a sorted array and a target value, return the index if the target is found.

    If not, return the index where it would be if it were inserted in order.

    You may assume no duplicates in the array.

    Here are few examples.
    [1,3,5,6], 5 -> 2
    [1,3,5,6], 2 -> 1
    [1,3,5,6], 7 -> 4
    [1,3,5,6], 0 -> 0

    https://leetcode.com/problems/search-insert-position/

\end{lstlisting}

\textbf{Solution}

Basic Binary Search algorithm

\javacode{Pro35}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 121 Best Time to Buy and Sell Stock
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large Problem 121 Best Time to Bey and Sell Stock}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Say you have an array for which the ith element is the price of a given stock
     on day i.

    If you were only permitted to complete at most one transaction
     (ie, buy one and sell one share of the stock),
      design an algorithm to find the maximum profit.

    https://leetcode.com/problems/best-time-to-buy-and-sell-stock/

\end{lstlisting}

\textbf{Solution 1}

~~Brute force algorithm, list all possibilities, $\bm{O(n^2) runtime}$, undoubtedly Time Limit Exceed.

\javacode{Pro121_1}{Solution 1}


\textbf{Solution 2}

~~Maintain a minimum value until just before current index, so that we may get a better result when selling current stock while minimum price bought, $\bm{O(n) runtime}$.

\javacode{Pro121_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 122 Best Time to Buy and Sell Stock II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large Problem 122 Best Time to Buy and Sell Stock II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Say you have an array for which the ith element
     is the price of a given stock on day i.

    Design an algorithm to find the maximum profit.
     You may complete as many transactions as you like
      (ie, buy one and sell one share of the stock multiple times).
       However, you may not engage in multiple transactions
        at the same time (ie, you must sell the stock before you buy again).

    https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/

\end{lstlisting}

\textbf{Solution}

~~Don't hesitate to use Greedy algorithm to solve the problem.

\javacode{Pro122}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 123 Best Time to Buy and Sell Stock III
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large Problem 123 Best Time to Buy and Sell Stock III}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Say you have an array for which the ith element
     is the price of a given stock on day i.

    Design an algorithm to find the maximum profit.
     You may complete at most two transactions.

    Note:
    You may not engage in multiple transactions at the same time
     (ie, you must sell the stock before you buy again).

    https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/

\end{lstlisting}

\textbf{Solution}

~~This solution here is a variant of Problem ``Best Time to Buy and Sell Stock''. We use each day as split point, respectively calculating maximum profits before and after the $i^{th}$ day, then compare all of them to get the real maximum profit.

~~BTW, when we look at the 4th problem of this series, the count of transaction is extended to k, so that we can just substitute 2 into k to get the result of this problem. The solution will be demonstrated in next Problem.

~~ However, simply apply such process will get TLE. We need to do some pre-processing. We may calculate maximum profit of [0,1],[0,2].... and [n-1,n],[n-2,n] so that we can reduce the complexity to $O(n)$

\javacode{Pro123}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 188 Best Time to Buy and Sell Stock IV
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large Problem 188 Best Time to Buy and Sell Stock IV}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Say you have an array for which the ith element
     is the price of a given stock on day i.

    Design an algorithm to find the maximum profit.
     You may complete at most k transactions.

    Note:
    You may not engage in multiple transactions at the same time
     (ie, you must sell the stock before you buy again).

    https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/

\end{lstlisting}

\textbf{Solution}

~~It's not a conventional way of using DP. Detailed Description can be seen below.

\includegraphics[width=1\columnwidth]{figures/188_best_time_to_buy_and_sell_stock_iv}

~~(Honestly, I don't quite understand the solution here.

\javacode{Pro188}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 309 Best Time to Buy and Sell Stock with Cooldown
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large Problem 309 Best Time to Buy and Sell Stock with Cooldown}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Say you have an array for which the ith element is
     the price of a given stock on day i.

    Design an algorithm to find the maximum profit.
     You may complete as many transactions as you like
      (ie, buy one and sell one share of the stock multiple times)
       with the following restrictions:

    You may not engage in multiple transactions at the same time
     (ie, you must sell the stock before you buy again).
    After you sell your stock, you cannot buy stock on next day.
     (ie, cooldown 1 day)
    Example:

    prices = [1, 2, 3, 0, 2]
    maxProfit = 3
    transactions = [buy, sell, cooldown, buy, sell]

    https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/

\end{lstlisting}

\textbf{Solution}

~~Another problem I didn't understand..........

\includegraphics[width=0.8\columnwidth]{figures/309_best_time_to_buy_and_sell_stock_with_cooldown}

\javacode{Pro309}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 125 Valid Palindrome
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large Problem 9 Palindrome Number}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given a string, determine if it is a palindrome, considering
     only alphanumeric characters and ignoring cases.

    For example,
    "A man, a plan, a canal: Panama" is a palindrome.
    "race a car" is not a palindrome.

    Note:
    Have you consider that the string might be empty? This is a good question to ask
     during an interview.

    For the purpose of this problem, we define empty string as valid palindrome.

    https://leetcode.com/problems/valid-palindrome/

\end{lstlisting}

\textbf{Solution}

~~Though it's just a easy string-handling problem with not many edge cases, I made several mistakes:
\begin{itemize}
    \item Ignoring the case problems of letters, should lowercase characters in sentence.
    \item Forgot to check boundaries, especially when all characters are non-alphanumeric, there will be an IndexOutOfBoundException.
\end{itemize}

\javacode{Pro125}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 206 Reverse Linked List
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large Problem 206 Reverse Linked List}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Reverse a singly linked list.

    Hint:
    A linked list can be reversed either iteratively or recursively.
     Could you implement both?


    https://leetcode.com/problems/reverse-linked-list/

\end{lstlisting}

\textbf{Solution 1}

Non-recursive solution, basically maintains 3 pointers, `cur', `next', next node of `next', see details in Listing \ref{Pro206_1}

\javacode{Pro206_1}{Solution 1}

\textbf{Solution 2}

Recursive solution.

\javacode{Pro206_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 92 Reverse Linked List II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 92 Reverse Linked List II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Reverse a linked list from position m to n.
     Do it in-place and in one-pass.

    For example:
    Given 1->2->3->4->5->NULL, m = 2 and n = 4,

    return 1->4->3->2->5->NULL.

    Note:
    Given m, n satisfy the following condition:
    1 $<=$ m $<=$ n $<=$ length of list.

    https://leetcode.com/problems/reverse-linked-list-ii/

\end{lstlisting}

\textbf{Solution}

Dummy node is a excellent aid when dealing with problems involving Linked-list.

The main idea of my solution is to firstly use dummy node to avoid talking about conditions when the reversion starts from the 1st element, which may need a lot of code to deal with empty head nodes; secondly iterate to the element where the reversion starts, record its previous node as the tail of 1st part of the whole 3 parts; reverse until the index reaches n; reconnect the tails of each parts by assigning .next attribute.

\javacode{Pro92}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 19 Remove Nth Node From End of List
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 19 Remove Nth Node From End of List}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given a linked list, remove the nth node from the end of list and return its head.

    For example,

       Given linked list: 1->2->3->4->5, and n = 2.

       After removing the second node from the end, the linked list becomes 1->2->3->5.
    Note:
    Given n will always be valid.
    Try to do this in one pass.

    https://leetcode.com/problems/remove-nth-node-from-end-of-list/

\end{lstlisting}

\textbf{Solution}

~~We can solve this problem by calculating its length first and get index of deleted node by length-n. However, this is not a solution in one-pass;

~~A tactful idea is that we first iterate one pointer n times, then iterate pointer describe above together with a pointer from head of the list, when the 1st point reaches the end of list, the 2nd point stays just at the node we want to remove. See \ref{Pro19}

\javacode{Pro19}{Solution}

\end{homeworkProblem}
\newpage


%----------------------------------------------------------------------------------------
%	PROBLEM 203 Remove Linked List Elements
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 203 Remove Linked List Elements}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Remove all elements from a linked list of integers that have value val.

    Example
    Given: 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6, val = 6
    Return: 1 --> 2 --> 3 --> 4 --> 5

    https://leetcode.com/problems/remove-linked-list-elements/

\end{lstlisting}

\textbf{Solution}

~~ An easy problem, just be aware of some edge cases such as inputting an empty list or a list full of values to be removed.

\javacode{Pro203}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 83 Remove Duplicates from Sorted List
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 83 Remove Duplicates from Sorted List}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a sorted linked list,
     delete all duplicates such that each element appear only once.

    For example,
    Given 1->1->2, return 1->2.
    Given 1->1->2->3->3, return 1->2->3.

    https://leetcode.com/problems/remove-duplicates-from-sorted-list/

\end{lstlisting}

\textbf{Solution}

~~ An easy problem, since list is sorted, just check if value of neighbor nodes are equal.

\javacode{Pro83}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 82 Remove Duplicates from Sorted List II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 82 Remove Duplicates from Sorted List II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given a sorted linked list, delete all nodes that have duplicate numbers,
     leaving only distinct numbers from the original list.

    For example,
    Given 1->2->3->3->4->4->5, return 1->2->5.
    Given 1->1->1->2->3, return 2->3.

    https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/

\end{lstlisting}

\textbf{Solution}

~~My solution is to use `prev' and `cur` pointer to deal with such problem. `prev' maintains lists which already be processed to have only distinct values; `cur' is used to skip all adjacent elements whose values are equal.

~~There is another interesting train of thought, where distinct value means the value of element is not equal to its neighbors(both left side and right side.).

\javacode{Pro82}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 328 Odd Even Linked List
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 328 Odd Even Linked List}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given a singly linked list,
     group all odd nodes together followed by the even nodes.
    Please note here we are talking about
     the node number and not the value in the nodes.

    You should try to do it in place. The program should run in
     O(1) space complexity and O(nodes) time complexity.

    Example:
    Given 1->2->3->4->5->NULL,
    return 1->3->5->2->4->NULL.
    Note:
    The relative order inside both the even and odd groups should remain as it was
     in the input.
    The first node is considered odd, the second node even and so on ...

    https://leetcode.com/problems/odd-even-linked-list/

\end{lstlisting}

\textbf{Solution}

~~ An easy problem, just to be aware of conditions when length of list is odd and even.

\javacode{Pro328}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 237 Delete Node in a Linked List
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 237 Delete Node in a Linked List}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Write a function to delete a node (except the tail) in a singly linked list,
     given only access to that node.

    Supposed the linked list is 1 -> 2 -> 3 -> 4 and you are given the third node
     with value 3, the linked list should become 1 -> 2 -> 4 after calling
      your function.

    https://leetcode.com/problems/delete-node-in-a-linked-list/

\end{lstlisting}

\textbf{Solution}

~~ An easy but weird problem, must use deep copy to finish the task, since OJ System will check the value of node with current index.

\javacode{Pro237}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 160 Intersection of Two Linked Lists
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 160 Intersection of Two Linked Lists}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Write a program to find the node at which
     the intersection of two singly linked lists begins.


    For example, the following two linked lists:

    A:          a1 -> a2
                       ->
                         c1 -> c2 -> c3
                       ->
    B:     b1 -> b2 -> b3
    begin to intersect at node c1.


    Notes:

    If the two linked lists have no intersection at all, return null.
    The linked lists must retain their original structure after the function returns.
    You may assume there are no cycles anywhere in the entire linked structure.
    Your code should preferably run in O(n) time and use only O(1) memory.

    https://leetcode.com/problems/intersection-of-two-linked-lists/

\end{lstlisting}

\textbf{Solution}

~~ Solution of this problem needs tactics.

~~ Brute force solution is definitely not good enough. The idea of $\bm{O(n) runtime}$ and $\bm{O(1) space}$ solution is similar to the idea in \emph{Problem 19 Remove Nth Node From End of List}, which needs to iterate the longer list several times(equals to the difference between two length), then iterate both lists since they are of same length currently.

\javacode{Pro160}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 21 Merge Two Sorted Lists
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 21 Merge Two Sorted Lists}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Merge two sorted linked lists and return it as a new list.
     The new list should be made by splicing together the nodes of the first two lists.

    https://leetcode.com/problems/merge-two-sorted-lists/

\end{lstlisting}

\textbf{Solution}

~~This problem indicates the importance of dummy node in solving linked list problems.

\javacode{Pro21}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 23 Merge k Sorted Lists
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 23 Merge k Sorted Lists}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Merge k sorted linked lists and return it as one sorted list.
     Analyze and describe its complexity.

    https://leetcode.com/problems/merge-k-sorted-lists/

\end{lstlisting}

\textbf{Solution 1 \& 2}

~~Solution 1 is Brute force. With $O(nk^2) runtime and O(1) space.$ ($nk^2$ comes from 2n + 3n + ... + kn). We may skip Solution 1 here.

~~ Solution 2 makes use of heap. Keep a heap with min root, pop one , link it into result, push its next node.

~~Since Heap has a complexity of log(k) runtime with nk elements, the whole process has a $O(kn logk) runtime and O(k) space$ complexity.

\javacode{Pro23_1}{Solution}

\textbf{Solution 3}


~~Solution 3 is still of $O(kn logk) runtime$ but with $O(1) space$.

~~ The number of lists reduces from:

~~~~$k -> k / 2 -> k / 4 -> ... -> 2 -> 1$

~~When the size of lists increases from :

~~~~$n -> 2n -> 4n -> ... -> 2^{logk}n$

~~ So the runtime complexity is:

~~~~$kn + k/2*2n + ... + 2^{logk}n = nk logk$

\javacode{Pro23_2}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 143 Reorder List
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 143 Reorder List}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given a singly linked list L: L0->L1->...->Ln-1->Ln,
    reorder it to: L0->Ln->L1->Ln-1->L2->Ln-2->...

    You must do this in-place without altering the nodes' values.

    For example,
    Given {1,2,3,4}, reorder it to {1,4,2,3}.

    https://leetcode.com/problems/reorder-list/

\end{lstlisting}

\textbf{Solution}

~~The train of thought is somewhat straightforward, just find the middle element, reverse the latter half, and reconnect elements in first half and second half. But not coding in IDE to solve a problem of Medium difficulty is impossible to me currently...

\javacode{Pro143}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 326 Power of Three
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 326 Power of Three}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given an integer, write a function to determine if it is a power of three.

    Follow up:
    Could you do it without using any loop / recursion?

    https://leetcode.com/problems/power-of-three/

\end{lstlisting}

\textbf{Solution}

~~Using recursion or loop is extremely easy, but not using both is a challenge. Note that $log_{3}(n)=\frac{log(n)}{log(3)}$ and it will return a integer if n is power of 3. Then we should just check if $div$ and $Math.round(div)$ has a difference less than 0.000000001(If we just check equation we may find 243 returns false because of precision problem in Java).

\javacode{Pro326}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 231 Power of Two
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 231 Power of Two}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given an integer, write a function to determine if it is a power of two.

    Follow up:
    Could you do it without using any loop / recursion?

    https://leetcode.com/problems/power-of-two/

\end{lstlisting}

\textbf{Solution 1}

~~Solution 1 is nearly the same as solution in Pro 326, \emph{Power of Two}, just change 3 into 2.

\javacode{Pro231_1}{Solution 1}


\textbf{Solution 2}

~~This solution is interesting. Speaking of 2(or 4,16, etc, we can do sqrt calculation first to make problem familiar), we may use bit operators to solve it. Both checking n-1 is all 1 in Binary or in form of 1000000 in Binary are fine.

\javacode{Pro231_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 342 Power of Four
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 342 Power of Four}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given an integer (signed 32 bits), write a function to check whether it is a power of 4.

    Example:
    Given num = 16, return true. Given num = 5, return false.

    Follow up: Could you solve it without loops/recursion?

    https://leetcode.com/problems/power-of-four/

\end{lstlisting}

\textbf{Solution 1}

~~First identify whether it is power of 2(simply using n\&(n-1)==0), then if it is , the form of the number must be like 10....0, check whether there are even number of 0 behind the heading 1.

~~ However, I'm still using a loop.

\javacode{Pro342_1}{Solution 1}

\textbf{Solution 2}

~~ Still, check if it is power of 2. Then use 0x55555555(1010101010101010101010101010101 in binary) to check if the single 1 only appears at odd position.

\javacode{Pro342_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 191 Number of 1 Bits
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 191 Number of 1 Bits}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Write a function that takes an unsigned integer and returns
     the number of '1' bits it has (also known as the Hamming weight).

    For example, the 32-bit integer '11' has
     binary representation 00000000000000000000000000001011,
      so the function should return 3.

    https://leetcode.com/problems/number-of-1-bits/

\end{lstlisting}

\textbf{Solution 1}

~~To be accurate, the 2 solutions are 2 ways of thinking rather than ways of solving problems. The first one uses $>>>$ (unsigned bit operator) and check if n is still larger than 0. \emph{DO NOT USE `$>>$'! It will overflow for $2^{32}$!}

\javacode{Pro191_1}{Solution 1}


\textbf{Solution 2}

~~The 2nd solution make use of the fact that the integer is at most 32 bits. It iterates the number for 32 bits to see whether 1 exists.

\javacode{Pro191_2}{Solution 2}

~~What's more, using n \& (n-1) also does excellent work. Mind those boundaries.

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 202 Happy Number
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 202 Happy Number}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Write an algorithm to determine if a number is "happy".

    A happy number is a number defined by the following process:
     Starting with any positive integer,
      replace the number by the sum of the squares of its digits,
       and repeat the process until the number equals 1 (where it will stay),
        or it loops endlessly in a cycle which does not include 1.
    Those numbers for which this process ends in 1 are happy numbers.

    Example: 19 is a happy number

    1*1 + 9*9 = 82
    8*8 + 2*2 = 68
    6*6 + 8*8 = 100
    1*1 + 0*0 + 0*0 = 1

    https://leetcode.com/problems/happy-number/

\end{lstlisting}

\textbf{Solution}

~~A set is enough for this problem.

\javacode{Pro202}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 61 Rotate List
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 61 Rotate List}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a list, rotate the list to the right by k places, where k is non-negative.

    For example:
    Given 1->2->3->4->5->NULL and k = 2,
    return 4->5->1->2->3->NULL.

    https://leetcode.com/problems/rotate-list/

\end{lstlisting}

\textbf{Solution}

~~Though this problem seems not that difficult, there are still some edge cases which needs to be dealt with.

~~The main idea of my solution is to use 2 pointers to get the `Nth element from the end'(sounds familiar), one goes faster for k steps.

~~Here comes the \textbf{TRAP}! When k is (much) larger than length of the list, we will get Time Limit Exceed error. So mod operator is in need here.

~~Also we need to be aware of the condition when k==0(or k==n where n\%n==0)

\javacode{Pro61}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 24 Swap Nodes in Pairs
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 24 Swap Nodes in Pairs}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a linked list, swap every two adjacent nodes and return its head.

    For example,
    Given 1->2->3->4, you should return the list as 2->1->4->3.

    Your algorithm should use only constant space.
     You may not modify the values in the list, only nodes itself can be changed.

    https://leetcode.com/problems/swap-nodes-in-pairs/

\end{lstlisting}


\textbf{Solution}

~~Not many tactics, just maintain 2 pointers to reverse cur and next.

\javacode{Pro24}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 66 Plus One
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 66 Plus One}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given a non-negative number represented as an array of digits,
     plus one to the number.

    The digits are stored such that
     the most significant digit is at the head of the list.

    https://leetcode.com/problems/plus-one/

\end{lstlisting}

\textbf{Solution}

~~Though it is correct to use carry like we usually do when doing sum action, plus one is not as complicated to use carry digit. See listing \ref{Pro66}, it's a pretty lovely solution.

\javacode{Pro66}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 2 Add Two Numbers
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 2 Add Two Numbers}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    You are given two linked lists representing two non-negative numbers.
     The digits are stored in reverse order and each of their nodes contain
      a single digit.
      Add the two numbers and return it as a linked list.

    Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
    Output: 7 -> 0 -> 8

    https://leetcode.com/problems/add-two-numbers/

\end{lstlisting}

\textbf{Solution}

~~Some sort of addition calculator with high precision. Some edge cases to be considered.

~~However, my solution is far from `Clean Code'.

\javacode{Pro2}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 223 Rectangle Area
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 223 Rectangle Area}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Find the total area covered by two rectilinear rectangles in a 2D plane.

    Each rectangle is defined by its bottom left corner and
     top right corner as shown in the figure.

    For Rectangle Area, see image below.
    Assume that the total area is never beyond the maximum possible value of int.

    https://leetcode.com/problems/rectangle-area/

\end{lstlisting}

\includegraphics[width=0.75\columnwidth]{figures/223_rectangle_area}

\textbf{Solution}

~~Quite an easy problem, just read the description of problem more carefully.

\javacode{Pro223}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 7 Reverse Integer
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 7 Reverse Integer}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Reverse digits of an integer.

    Example1: x = 123, return 321
    Example2: x = -123, return -321

    click to show spoilers.

    Have you thought about this?
    Here are some good questions to ask before coding.
     Bonus points for you if you have already thought through this!

    If the integer's last digit is 0, what should the output be?
     ie, cases such as 10, 100.

    Did you notice that the reversed integer might overflow?
     Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows.
      How should you handle such cases?

    For the purpose of this problem,
     assume that your function returns 0 when the reversed integer overflows.

    https://leetcode.com/problems/reverse-integer/

\end{lstlisting}


\textbf{Solution}

~~Two points which may attract interviewers if you have mentioned,

~~\begin{itemize}
\item What will happen if I input minus number?
\item What if the reversed number overflows?
~~\end{itemize}


~~ And solution in `Clean Code Handbook' seems mistaken since it only consider the condition when sum $>$ MAX\_VALUE/10 and there still remains unresolved number. What about 2147483649?

~~ Honestly, I don't think it is a problem as easy as I imagined at first sight.

\javacode{Pro7}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 190 Reverse Bits
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 190 Reverse Bits}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Reverse bits of a given 32 bits unsigned integer.

    For example, given input 43261596
     (represented in binary as 00000010100101000001111010011100),
      return 964176192 (represented in binary as 00111001011110000010100101000000).

    Follow up:
    If this function is called many times, how would you optimize it?

    https://leetcode.com/problems/reverse-bits/

\end{lstlisting}


\textbf{Solution}

~~ Basically it is an easy bit manipulation problem. But when we need to call it several times, the method of optimization can be found \url{http://articles.leetcode.com/reverse-bits}.

\javacode{Pro190}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 141 Linked List Cycle
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 141 Linked List Cycle}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a linked list, determine if it has a cycle in it.

    Follow up:
    Can you solve it without using extra space?

    https://leetcode.com/problems/linked-list-cycle/

\end{lstlisting}


\textbf{Solution}

~~Still, the slow and fast pointer, if the list has cycle inside, the slow pointer will be caught sooner or later.

\javacode{Pro141}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 142 Linked List Cycle II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 142 Linked List Cycle II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a linked list, return the node where the cycle begins.
     If there is no cycle, return null.

    Note: Do not modify the linked list.

    Follow up:
    Can you solve it without using extra space?

    https://leetcode.com/problems/linked-list-cycle-ii/

\end{lstlisting}


\textbf{Solution}

~~ If no restrictions in that `Note', we can easily handle this by HashSet.

~~ Now we can only use mathematical method to solve this problem.

~~ Forget about this problem for a moment. How can we get the length of cycle? When slow and fast pointers continues iterating so as to meet for the 2nd time, the slow pointer passes exactly the length of the whole cycle(or an integral multiple of cycle length)!

~~ Coming back to this problem, we assign `a' as length from head of list to where the cycle begins, `b' as length from where cycle begins to where 2 pointers met, `c' as length passed by fast pointer after it first passed the node where they met.

~~ Then?

~~$2(a + b) = a + b + c$, here $c$ may be l*R, then we get a = c - b!!!

~~ Which means, if we re-assign 2 pointers, let one starts from head of list, the other starts from where they met, they will meet at where the cycle begins!

~~ For more details, refer to \url{http://blog.sina.com.cn/s/blog\_6f611c300101fs1l.html}

\javacode{Pro142}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 13 Roman to Integer
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 13 Roman to Integer}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a roman numeral, convert it to an integer.

    Input is guaranteed to be within the range from 1 to 3999.

    https://leetcode.com/problems/roman-to-integer/

\end{lstlisting}


\textbf{Solution}

~~ Main idea is simple, just to check each character and sum up those values.

~~ However, those IX(for 9, 11 is XI) and Xl are special(they are designed for the purpose that the same notation won't appear for more than 3 times in a row.), honestly we can deal with all kinds of patterns, we still have a simplified algorithm: when cur digit is larger than prev(IX, X is larger), then we should add cur to sum and remove prev for 2 times. sum = sum + cur - 2 * prev.

\javacode{Pro13}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 12 Integer to Roman
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 12 Integer to Roman}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an integer, convert it to a roman numeral.

    Input is guaranteed to be within the range from 1 to 3999.

    https://leetcode.com/problems/integer-to-roman/

\end{lstlisting}


\textbf{Solution}

~~ Find biggest value, remove it, and append corresponding Roman notation to String.

~~ Difficult thing is that there exists IX or XV to indicate reduction. Luckily, there is a given information that integer is 1$\sim$3999, so that we can list all possible notation patterns since IX always appear after X(9 $<$ 10, 10 comes first).

\javacode{Pro12}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 168 Excel Sheet Column Title
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 168 Excel Sheet Column Title}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a positive integer,
     return its corresponding column title as appear in an Excel sheet.

    For example:

        1 -> A
        2 -> B
        3 -> C
        ...
        26 -> Z
        27 -> AA
        28 -> AB

    https://leetcode.com/problems/excel-sheet-column-title/

\end{lstlisting}


\textbf{Solution}

~~ We can regard the integer as an number with base-26(binary is base-2 and decimal is base-10), but there is another thing we need to be aware of - base-2 consists only 0 and 1, where A-Z usually represents 1-26. So we should normalize our number, by reducing 1 to the integer we can normalize A-Z to 0-25.

\javacode{Pro168}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 171 Excel Sheet Column Number
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 171 Excel Sheet Column Number}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Related to question Excel Sheet Column Title

    Given a column title as appear in an Excel sheet, return its corresponding column number.

    For example:

        A -> 1
        B -> 2
        C -> 3
        ...
        Z -> 26
        AA -> 27
        AB -> 28

    https://leetcode.com/problems/excel-sheet-column-number/

\end{lstlisting}


\textbf{Solution}

~~ It's just a reversion of its related problem.

\javacode{Pro171}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 60 Permutation Sequence
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 60 Permutation Sequence}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    The set [1,2,3,,n] contains a total of n! unique permutations.

    By listing and labeling all of the permutations in order,
    We get the following sequence (ie, for n = 3):

    "123"
    "132"
    "213"
    "231"
    "312"
    "321"
    Given n and k, return the kth permutation sequence.

    Note: Given n will be between 1 and 9 inclusive.

    https://leetcode.com/problems/permutation-sequence/

\end{lstlisting}


\textbf{Solution 1}

~~This is maybe the 1st backtracking problem solved by myself!!

~~In fact, the problem can be solved without recursion in Listing \ref{Pro60_2}

~~ The idea of solving this problem is to justify each digit from the most significant digit. Using (k - 1) / (n - 1)! we can get the index of current digit and remaining numbers.

~~For example, for n = 3 and k = 4, the 1st digit is decided by (4 - 1) / (3 - 1)! = 1 remains 1, so the 1st digit is the (1+1), 2nd biggest element in remaining set, which is 2; recursively, the whole number is 231.

\javacode{Pro60_1}{Solution 1}


\textbf{Solution 2}
\ccode{Pro60_2}{Solution 2}

\textbf{Solution 3}
There is a more interesting solution, given the fact that the numbers only contains 1-9.
\ccode{Pro60_3}{Solution 3}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 46 Permutations
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 46 Permutations}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a collection of distinct numbers, return all possible permutations.

    For example,
    [1,2,3] have the following permutations:
    [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].

    https://leetcode.com/problems/permutations/

\end{lstlisting}

\textbf{Solution}

~~ It is a representative problem of backtracking or recursion.

~~ In fact, there are all kinds of algorithms to generate all-permutations.

 ~~See \url{http://blog.csdn.net/ljiabin/article/details/40151393}

\javacode{Pro46}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 31 Next Permutation
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 31 Next Permutation}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Implement next permutation, which rearranges numbers into the lexicographically
     next greater permutation of numbers.

    If such arrangement is not possible, it must rearrange it as
     the lowest possible order (ie, sorted in ascending order).

    The replacement must be in-place, do not allocate extra memory.

    Here are some examples. Inputs are in the left-hand column
     and its corresponding outputs are in the right-hand column.
        1,2,3 -> 1,3,2
        3,2,1 -> 1,2,3
        1,1,5 -> 1,5,1

    https://leetcode.com/problems/next-permutation/

\end{lstlisting}

\textbf{Solution}

~~ Utilizes a lexicographical order Algorithm.

~~ The algorithm is explained as below.

\includegraphics[width=0.75\columnwidth]{figures/31_next_permutation_1}


\includegraphics[width=0.75\columnwidth]{figures/31_next_permutation_2}

\javacode{Pro31}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 47 Permutations II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 47 Permutations II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a collection of numbers that might contain duplicates, return
     all possible unique permutations.

    For example,
    [1,1,2] have the following unique permutations:
    [1,1,2], [1,2,1], and [2,1,1].

    https://leetcode.com/problems/permutations-ii/

\end{lstlisting}

\textbf{Solution}

~~ We can use the same algorithm from Pro-31 to get the next permutation, but remember to sort the array first, or it may lose some results.

~~ It can also be solved by backtracking method.

\javacode{Pro47}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 77 Combinations
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 77 Combinations}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a collection of numbers that might contain duplicates,
     return all possible unique permutations.

    For example,
    [1,1,2] have the following unique permutations:
    [1,1,2], [1,2,1], and [2,1,1].Given two integers n and k,
     return all possible combinations of k numbers out of 1 ... n.

    For example,
    If n = 4 and k = 2, a solution is:

    [
      [2,4],
      [3,4],
      [2,3],
      [1,2],
      [1,3],
      [1,4],
    ]

    https://leetcode.com/problems/combinations/

\end{lstlisting}

\textbf{Solution}

~~ A dfs problem, similar but not quite same as Problem ``Permutations'', Permutations aim at swapping elements, this one is more like ``N-Queens''.

\javacode{Pro77}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 172 Factorial Trailing Zeroes
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 172 Factorial Trailing Zeroes}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an integer n, return the number of trailing zeroes in n!.

    Note: Your solution should be in logarithmic time complexity.

    https://leetcode.com/problems/factorial-trailing-zeroes/

\end{lstlisting}

\textbf{Solution}

~~ What decides the number of trailing 0 is how many numbers has the factor of 5(since 5*2=10 and count of 2 is much more than 5). Note that not only 5 should be considered, 25 provides two 5s, which also needs to be take into consideration.

\javacode{Pro172}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 8 String to Integer (atoi)
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 8 String to Integer (atoi)}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Implement atoi to convert a string to an integer.

    Hint: Carefully consider all possible input cases. If you want a challenge,
     please do not see below and ask yourself what are the possible input cases.

    Notes: It is intended for this problem to be specified vaguely
     (ie, no given input specs).
     You are responsible to gather all the input requirements up front.


    Requirements for atoi:
    The function first discards as many whitespace characters as necessary
     until the first non-whitespace character is found.
      Then, starting from this character, takes an optional initial plus or minus sign
       followed by as many numerical digits as possible, and interprets them
        as a numerical value.

    The string can contain additional characters after those that
     form the integral number,
     which are ignored and have no effect on the behavior of this function.

    If the first sequence of non-whitespace characters in str
     is not a valid integral number, or if no such sequence exists
      because either str is empty or it contains only whitespace characters,
       no conversion is performed.

    If no valid conversion could be performed, a zero value is returned.
     If the correct value is out of the range of representable values,
      INT_MAX (2147483647) or INT_MIN (-2147483648) is returned.

    https://leetcode.com/problems/string-to-integer-atoi/

\end{lstlisting}

\textbf{Solution}

~~ The biggest difficulty of this problem is that there are so many edge cases(though less than those in valid number).

\javacode{Pro8}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 28 Implement strStr()
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 28 Implement strStr()}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Implement strStr().

    Returns the index of the first occurrence of needle in haystack,
     or -1 if needle is not part of haystack.

    https://leetcode.com/problems/implement-strstr/

\end{lstlisting}

\textbf{Solution}

~~An easy string manipulating problem. Since I'm using a $O(mn)$ solution, and there's another famous algorithm named KMP which can solve this problem with lower complexity, the solution has the space for improvement.

~~ And also don't forget the solution on ``Clean Code Handbook''.

\javacode{Pro28}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 169 Majority Element
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 169 Majority Element}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an array of size n, find the majority element.
     The majority element is the element that appears more than floor(n/2) times.

    You may assume that the array is non-empty and the majority element always exist
     in the array.

    https://leetcode.com/problems/majority-element/

\end{lstlisting}

\textbf{Solution 1}

~~ This is my solution, luckily write out \textbf{Moore voting algorithm}, though not `Clean Code':

~~ We maintain a current candidate and a counter initialized to 0. As we iterate the array, we look at the current element x:

~~~~~~~~~~If the counter is 0, we set the current candidate to x and the counter to 1.

~~~~~~~~If the counter is not 0, we increment or decrement the counter based on whether x is the current candidate.

~~~~~~After one pass, the current candidate is the majority element. Runtime complexity = O(n).

\javacode{Pro169_1}{Solution 1}

\textbf{Solution 2}

~~The reason why I record Solution 2 in such an excitement is that the algorithm is FXXXING excellent!!

~~We would need 32 iterations, each calculating the number of 1's for the ith bit of all n numbers. Since a majority must exist, therefore, either count of 1's $>$ count of 0's or vice versa (but can never be equal). The majority numbers ith bit must be the one bit that has the greater count.(Words below are copied from Solutions of this problem in Leetcode)

\javacode{Pro169_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 229 Majority Element II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 229 Majority Element II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an integer array of size n,
     find all elements that appear more than floor(n/3) times.
      The algorithm should run in linear time and in O(1) space.

    Hint:

    How many majority elements could it possibly have?

    https://leetcode.com/problems/majority-element-ii/

\end{lstlisting}


\textbf{Solution}

~~Also, use Moore's Voting Algorithm, this time we have 2 candidates comparing to other nodes. Remember to check finally whether the two candidates are all majority elements we want since there may be only one majority element.

\javacode{Pro229_1}{Solution 1}

\textbf{Another interesting solution}

~~From `Clean Code Handbook`, with comments served as description.

\ccode{Pro229_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 67 Add Binary
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 67 Add Binary}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given two binary strings, return their sum (also a binary string).

    For example,
    a = "11"
    b = "1"
    Return "100".

    https://leetcode.com/problems/add-binary/

\end{lstlisting}

\textbf{Solution}

~~ An easy problem just like ``Add Two Number'', easier.

\javacode{Pro67}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 258 Add Digits
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 258 Add Digits}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a non-negative integer num, repeatedly add all its digits
     until the result has only one digit.

    For example:

    Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2.
     Since 2 has only one digit, return it.

    Follow up:
    Could you do it without any loop/recursion in O(1) runtime?

    Hint:

    A naive implementation of the above process is trivial.
     Could you come up with other methods?

    https://leetcode.com/problems/add-digits/

\end{lstlisting}

\textbf{Solution 1}

~~ First come up with the ``naive'' solution.

\javacode{Pro258_1}{Solution 1}

\textbf{Solution 2}

~~ Solution 2 is interesting and simple! See figure below.

\includegraphics[width=0.75\columnwidth]{figures/258_add_digits}

\javacode{Pro258_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 233 Number of Digit One
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 233 Number of Digit One}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an integer n, count the total number of digit 1 appearing
     in all non-negative integers less than or equal to n.

    For example:
    Given n = 13,
    Return 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.

    Hint:

    Beware of overflow.

    https://leetcode.com/problems/number-of-digit-one/

\end{lstlisting}

\textbf{Solution}

~~ Honestly, I don't think I totally understand the solution, so that I'll list my current train of thought in case of forgetting.

\includegraphics[width=1\columnwidth]{figures/233_number_of_digit_one}


\javacode{Pro233}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 204 Count Primes
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 204 Count Primes}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Count the number of prime numbers less than a non-negative number, n.

    https://leetcode.com/problems/count-primes/

\end{lstlisting}

\textbf{Solution 1}

~~First solution is straightforward but a bit inefficient.

\javacode{Pro204_1}{Solution 1}

\textbf{Solution 2}

~~ Solution 2 is actually extracted from the hint spoilers from problem descriptions, since it is such a litany, I put it in solution description rather than in problem.

\begin{enumerate}
\item Let's start with a isPrime function. To determine if a number is prime, we need to check if it is not divisible by any number less than n. The runtime complexity of isPrime function would be $O(n)$ and hence counting the total prime numbers up to n would be $O(n^2)$. Could we do better?

\item As we know the number must not be divisible by any number $>$ n / 2, we can immediately cut the total iterations half by dividing only up to n / 2. Could we still do better?

\item {Let's write down all of 12's factors:

        2 * 6 = 12

        3 * 4 = 12

        4 * 3 = 12

        6 * 2 = 12}

\item {As you can see, calculations of 4 * 3 and 6 * 2 are not necessary. Therefore, we only need to consider factors up to $\sqrt{n}$ because, if n is divisible by some number p, then n = p * q and since p $<=$ q, we could derive that p $<=$ $\sqrt{n}$.

    Our total runtime has now improved to $O(n^{1.5})$, which is slightly better. Is there a faster approach?
    Code see solution 1.
}


\item {The Sieve of Eratosthenes is one of the most efficient ways to find all prime numbers up to n. But don't let that name scare you, I promise that the concept is surprisingly simple.


    For figure of the algorithm,

     see \url{https://leetcode.com/static/images/solutions/Sieve\_of\_Eratosthenes\_animation.gif}.

    We start off with a table of n numbers. Let's look at the first number, 2. We know all multiples of 2 must not be primes, so we mark them off as non-primes. Then we look at the next number, 3. Similarly, all multiples of 3 such as 3 * 2 = 6, 3 * 3 = 9, ... must not be primes, so we mark them off as well. Now we look at the next number, 4, which was already marked off. What does this tell you? Should you mark off all multiples of 4 as well?}

 \item { 4 is not a prime because it is divisible by 2, which means all multiples of 4 must also be divisible by 2 and were already marked off. So we can skip 4 immediately and go to the next number, 5. Now, all multiples of 5 such as 5 * 2 = 10, 5 * 3 = 15, 5 * 4 = 20, 5 * 5 = 25, ... can be marked off. There is a slight optimization here, we do not need to start from 5 * 2 = 10. Where should we start marking off?}

\item { In fact, we can mark off multiples of 5 starting at 5 * 5 = 25, because 5 * 2 = 10 was already marked off by multiple of 2, similarly 5 * 3 = 15 was already marked off by multiple of 3. Therefore, if the current number is p, we can always mark off multiples of p starting at p2, then in increments of p: p2 + p, p2 + 2p, ... Now what should be the terminating loop condition?}

\item {It is easy to say that the terminating loop condition is p $<$ n, which is certainly correct but not efficient. Do you still remember Hint $\sharp$3?}

\item{ Yes, the terminating loop condition can be p $<$ $\sqrt{n}$, as all non-primes $>=$ $\sqrt{n}$ must have already been marked off. When the loop terminates, all the numbers in the table that are non-marked are prime.

The Sieve of Eratosthenes uses an extra $O(n)$ memory and its runtime complexity is $O(n log log n)$. For the more mathematically inclined readers, you can read more about its algorithm complexity on Wikipedia.
    Code snippets are in Solution listing.}


\end{enumerate}

\javacode{Pro204_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 20 Valid Parentheses
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 20 Valid Parentheses}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a string containing just the characters '(', ')', '{', '}', '[' and ']',
     determine if the input string is valid.

    The brackets must close in the correct order,
     "()" and "()[]{}" are all valid but "(]" and "([)]" are not.

    https://leetcode.com/problems/valid-parentheses/

\end{lstlisting}

\textbf{Solution}

~~ A representative stack problem, use stack to hold left parentheses, pop when meet right hands, check if match.


\javacode{Pro20}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 32 Longest Valid Parentheses
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 32 Longest Valid Parentheses}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a string containing just the characters '(' and ')',
     find the length of the longest valid (well-formed) parentheses substring.

    For "(()", the longest valid parentheses substring is "()",
     which has length = 2.

    Another example is ")()())", where
     the longest valid parentheses substring is "()()", which has length = 4.

    https://leetcode.com/problems/longest-valid-parentheses/

\end{lstlisting}

\textbf{Solution}

~~ It is a dp problem, but we can first think about how to solve it in Brute force Method, which is of $O(n^2) runtime$ and will get Time Limit Exceed error.

~~ The dp solution is as listing. Interestingly, the array iterates from the end of string, dp[i] indicates the length of longest valid parentheses starts from index i. Of course when s[i] is `)' it cannot be the start point, so we only need to consider the `(' condition. if dp[i+1] $>$ 0, which means there are valid ()s starts from i+1, then we should check if s[i+dp[i+1]+1] is `)', if is the valid ()s ends at i+dp[i+1]+1 then dp=dp[i+1]+2.

~~This is not over, since dp[i+dp[i+1]+2] may not be 0, which we also need to take into addition.(We don't need to finish such process recursively since the process is done when we were calculating dp[i+dp[i+1]+2]).

~~ Be sure to check every boundaries conditions!!!

\ccode{Pro32_1}{Solution Brute force}

\javacode{Pro32_2}{Solution DP}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 155 Min Stack
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 155 Min Stack}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Design a stack that supports push, pop, top,
     and retrieving the minimum element in constant time.

        push(x) -- Push element x onto stack.
        pop() -- Removes the element on top of the stack.
        top() -- Get the top element.
        getMin() -- Retrieve the minimum element in the stack.

    https://leetcode.com/problems/min-stack/

\end{lstlisting}

\textbf{Solution}

~~ We can use a stack with the same size of original stack to maintain the minimum value, however, we don't have to need such a large stack. What we need to do is to record elements less than current minimum value, and take care to check equation when popping take place.

\javacode{Pro155}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 239 Sliding Window Maximum
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 239 Sliding Window Maximum}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an array nums, there is a sliding window of size k
     which is moving from the very left of the array to the very right.
      You can only see the k numbers in the window.
       Each time the sliding window moves right by one position.

    For example,
    Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.

    Window position                Max
    ---------------               -----
    [1  3  -1] -3  5  3  6  7       3
     1 [3  -1  -3] 5  3  6  7       3
     1  3 [-1  -3  5] 3  6  7       5
     1  3  -1 [-3  5  3] 6  7       5
     1  3  -1  -3 [5  3  6] 7       6
     1  3  -1  -3  5 [3  6  7]      7
    Therefore, return the max sliding window as [3,3,5,5,6,7].

    Note:
    You may assume k is always valid,
     ie: 1 <= k <= input array's size for non-empty array.

    Follow up:
    Could you solve it in linear time?

    Hint:

    How about using a data structure such as deque (double-ended queue)?
    The queue size need not be the same as the windows size.
    Remove redundant elements and the queue
     should store only elements that need to be considered.

    https://leetcode.com/problems/sliding-window-maximum/

\end{lstlisting}

\textbf{Solution}

~~ There are many solutions to solve such problem, the simplest but slowest way is using Brute force, which is of $O(nk) runtime.$

~~ Other ways of solving it are listed as below,

\includegraphics[width=1\columnwidth]{figures/239_sliding_window_maximum_1}

~~ Let's see an example.

\includegraphics[width=1\columnwidth]{figures/239_sliding_window_maximum_2}

~~LinkedList in Java has similar interface as deque in C++.

~~(BTW, there is another way to solve it...) Just think about ``PROBLEM 155 Min Stack'', We have already implemented a min stack with $O(1) runtime$ pop(), push() and getMin(), we can accomplish max stack in a similar way, so that we can use the stack to finish this task.

\javacode{Pro239}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 189 Rotate Array
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 189 Rotate Array}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Rotate an array of n elements to the right by k steps.

    For example, with n = 7 and k = 3,
     the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].

    Note:
        Try to come up as many solutions as you can,
         there are at least 3 different ways to solve this problem.


    Hint:
        Could you do it in-place with O(1) extra space?
        Related problem: Reverse Words in a String II

    https://leetcode.com/problems/rotate-array/

\end{lstlisting}

\textbf{Solution 1}

~~ Problem ask us to solve the problem in 3 different ways, I'll list my own solutions, and list others in below sections(only description, no code).

~~ Solution 1 is simple, just use another array to simulate the process in description.

\javacode{Pro189_1}{Solution 1}

\textbf{Solution 2}

~~ Solution is to move every bit backward for k digits, but which digit should I swap with? This solution forms a cycle, for example, if n = 9, k = 3, we shall swap a[0] to a[3], then a[3] to a[6], next one should be a[0], which returns to start point. Now we should finish this cycle and move cursor to next digit, namely a[1] to a[4]...

\javacode{Pro189_2}{Solution 2}

\textbf{Solution 3}

~~An interesting algorithm, similar to algorithm followed in ``Reverse Words in a String II''. Reverse 1st half, reverse 2nd half, reverse the whole sequence.

\javacode{Pro189_3}{Solution 3}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 263 Ugly Number
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 263 Ugly Number}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Write a program to check whether a given number is an ugly number.

    Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.
     For example, 6, 8 are ugly while 14 is not ugly
      since it includes another prime factor 7.

    Note that 1 is typically treated as an ugly number.

    https://leetcode.com/problems/ugly-number/

\end{lstlisting}

\textbf{Solution}

~~ This is quite an easy problem!

\javacode{Pro263}{Solution}



\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 264 Ugly Number II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 264 Ugly Number II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Write a program to find the n-th ugly number.

    Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.
     For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of
      the first 10 ugly numbers.

    Note that 1 is typically treated as an ugly number.

    Hint:

    The naive approach is to call isUgly for every number
     until you reach the nth one. Most numbers are not ugly.
      Try to focus your effort on generating only the ugly ones

    An ugly number must be multiplied by either 2, 3, or 5 from a smaller ugly number.

    The key is how to maintain the order of the ugly numbers.
     Try a similar approach of merging from three sorted lists: L1, L2, and L3.

    Assume you have Uk, the kth ugly number. Then Uk+1 must be
     Min(L1 * 2, L2 * 3, L3 * 5).

    https://leetcode.com/problems/ugly-number-ii/

\end{lstlisting}

\textbf{Solution}

~~ Solution is as Hint said.

\javacode{Pro264}{Solution}



\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 313 Super Ugly Number
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 313 Super Ugly Number}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Write a program to find the nth super ugly number.

    Super ugly numbers are positive numbers whose all prime factors
     are in the given prime list primes of size k.
      For example, [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32]
       is the sequence of the first 12 super ugly numbers
        given primes = [2, 7, 13, 19] of size 4.

    Note:
    (1) 1 is a super ugly number for any given primes.
    (2) The given numbers in primes are in ascending order.
    (3) 0 < k <= 100, 0 < n <= 106, 0 < primes[i] < 1000.

    https://leetcode.com/problems/ugly-number-ii/

\end{lstlisting}

\textbf{Solution}

~~ This is just a general circumstance of Problem 264 ``Ugly Number II'', so just utilize the same algorithm is fine.

\javacode{Pro313}{Solution}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 228 Summary Ranges
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 228 Summary Ranges}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a sorted integer array without duplicates, return the summary of its ranges.

    For example, given [0,1,2,4,5,7], return ["0->2","4->5","7"].

    https://leetcode.com/problems/summary-ranges/

\end{lstlisting}

\textbf{Solution}

~~ An easy problem. Simulation solution works.

\javacode{Pro228}{Solution}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 88 Merge Sorted Array
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 88 Merge Sorted Array}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1
     as one sorted array.

    Note:
    You may assume that nums1 has enough space
     (size that is greater or equal to m + n) to hold additional elements from nums2.
      The number of elements initialized in nums1 and nums2 are m and n respectively.

    https://leetcode.com/problems/merge-sorted-array/

\end{lstlisting}

\textbf{Solution}

~~ We can solve the problem in-place(using a new array is too simple, so that I won't put it here.), in order to resist conflict, we can start from the end of array, the worst situation is all elements in s2 is larger than s1, even so there won't be conflicts.

\javacode{Pro88}{Solution}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 279 Perfect Squares
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 279 Perfect Squares}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a positive integer n, find the least number of perfect square numbers
     (for example, 1, 4, 9, 16, ...) which sum to n.

    For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13,
     return 2 because 13 = 4 + 9.

    https://leetcode.com/problems/perfect-squares/

\end{lstlisting}

\textbf{Solution 1}

~~ Tags helps a lot. I found a tag named breadth-first search, then I realize that such combination problem which finds minimum count is perfect for BFS. Add to each element $poll$ed from queue from biggest available square number, if sum is larger then continue, smaller then $offer$ to queue, finally equal to get result. Next step is to try the DP tag...

\javacode{Pro279_1}{Solution 1}

\textbf{Solution 2}

~~Train of thought is similar to 0-1 knapsack problems. $dp[i] = min{dp[i - square_k] + 1}$

\javacode{Pro279_2}{Solution 2}

\textbf{Solution 3}

~~ Solution 3 is pretty mathematically. Lagrange's four-square theorem states that every natural number can be represented by the sum of no more than 4 square numbers.

\includegraphics[width=0.75\columnwidth]{figures/279_perfect_squares}

\ccode{Pro279_3}{Solution 3}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 322 Coin Change
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 322 Coin Change}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    You are given coins of different denominations and a total amount of money amount.
     Write a function to compute the fewest number of coins that
      you need to make up that amount.
       If that amount of money cannot be made up by any combination of the coins,
        return -1.

    Example 1:
    coins = [1, 2, 5], amount = 11
    return 3 (11 = 5 + 5 + 1)

    Example 2:
    coins = [2], amount = 3
    return -1.

    Note:
    You may assume that you have an infinite number of each kind of coin.

    https://leetcode.com/problems/coin-change/

\end{lstlisting}

\textbf{Solution}

~~Knapsack problem. Simple but I'm confused!

\javacode{Pro322}{Solution}

~~We can also switch the outer and inner for loop, then compared it with Problem 279 ``Perfect Squares''. Notice something?

\javacode{Pro322_2}{Solution1.2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 111 Minimum Depth of Binary Tree
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 111 Minimum Depth of Binary Tree}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a binary tree, find its minimum depth.

    The minimum depth is the number of nodes along the shortest path
     from the root node down to the nearest leaf node.

    https://leetcode.com/problems/minimum-depth-of-binary-tree/

\end{lstlisting}

\textbf{Solution 1}

~~ An easy problem. Solution 1 uses DFS. Don't forget to check the condition when one of the current node's child is null while another isn't.

\javacode{Pro111_1}{Solution 1}

\textbf{Solution 2}

~~ BFS is simpler, faster and more natural. We can stop whenever we first meet a node without children. Edge case is root == null.

\javacode{Pro111_2}{Solution 2}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 104 Maximum Depth of Binary Tree
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 104 Maximum Depth of Binary Tree}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a binary tree, find its maximum depth.

    The maximum depth is the number of nodes along the longest path
     from the root node down to the farthest leaf node.

    https://leetcode.com/problems/maximum-depth-of-binary-tree/

\end{lstlisting}

\textbf{Solution 1}

~~ Similar to Problem 104 ``Minimum Depth of Binary Tree''. Solution 1 uses DFS. It's interesting that we don't need to check if one child is null while another not, since we are fetching the maximum value.

\javacode{Pro104_1}{Solution 1}

\textbf{Solution 2}

~~ When using BFS, se stop when all levels are traversed, namely when queue is empty. Edge case is root == null. Don't forget to check if input parameter is null (when using BFS)!

\javacode{Pro104_2}{Solution 2}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 215 Kth Largest Element in an Array
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 215 Kth Largest Element in an Array}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Find the kth largest element in an unsorted array.
     Note that it is the kth largest element in the sorted order,
      not the kth distinct element.

    For example,
    Given [3,2,1,5,6,4] and k = 2, return 5.

    Note:
    You may assume k is always valid, 1 $<=$ k $<=$ array's length.

    https://leetcode.com/problems/minimum-depth-of-binary-tree/

\end{lstlisting}

\textbf{Solution 1}

~~ This is a good problem! Solution 1 is great, it utilize half of QuickSort -- the partition part. During quicksort, when we decide to put a pivot, the pivot is at exactly where it should be in a sorted array(then numbers on both sides are sorted respectively.). So we can check if the index of pivot is what we want - k, or more accurate, nums.length - k, if so, the question is answered.

\javacode{Pro215_1_1}{Solution 1.1}

~~I found another solution on Internet which also has a fantastic train of thought.(Divide and Conquer, I almost missed this point.)

~~~~In this problem, k means the index, namely how many numbers are there that is equal(itself) and bigger than the element. Then the author partitioned two array, storing elements larger and elements smaller,

~~~~~~when length of array of larger numbers is not adequate(k $>$ bigger.length), find in larger set for the element that still have k elements larger than itself;

~~~~~~if k - 1 $<$ bigger.length, then find in the smaller number set, k should be transformed into k - length - 1(no longer need k bigger numbers).

~~~~~~If (k - 1 == bigger.length), we get the result.

\ccode{Pro215_1_2}{Solution 1.2}

\textbf{Solution 2}

~~ We can also use Heap sort to solve this problem. Since PriorityQueue is made of heap, we use PriorityQueue to solve the problem. An optimization can be take place to reduce $O(n logn) runtime$ to $O(n logk)$, to generate a heap with k elements at first, and insert remaining n - k elements into heap if the element is , finally get the element from the top.

~~ Explain it. If we are finding the kth biggest element, we shall build a heap with small root using the first kth elements, so the root of the heap is exactly the kth biggest element(1st smallest) among all elements. For the rest of them, if the element is larger than top element, it will affect the ranking of elements, so poll the top element and add current element into heap; if element is smaller, just ignore it.

\javacode{Pro215_2}{Solution 2}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 102 Binary Tree Level Order Traversal
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 102 Binary Tree Level Order Traversal}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a binary tree, return the level order traversal of its nodes' values.
     (ie, from left to right, level by level).

    For example:
    Given binary tree {3,9,20,#,#,15,7},
        3
       / \
      9  20
        /  \
       15   7
    return its level order traversal as:
    [
      [3],
      [9,20],
      [15,7]
    ]
    confused what "{1,#,2,3}" means?


    OJ's Binary Tree Serialization:
    The serialization of a binary tree follows a level order traversal,
     where '#' signifies a path terminator where no node exists below.

    Here's an example:
       1
      / \
     2   3
        /
       4
        \
         5
    The above binary tree is serialized as "{1,2,3,#,#,4,#,#,5}".

    https://leetcode.com/problems/binary-tree-level-order-traversal/

\end{lstlisting}

\textbf{Solution 1}

~~ A standard BFS Problem.

\javacode{Pro102_1}{Solution 1}

\textbf{Solution 2}

~~ Use recursion(somewhat DFS) to maintain nodes related to its level.

\javacode{Pro102_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 107 Binary Tree Level Order Traversal II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 107 Binary Tree Level Order Traversal II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a binary tree, return the level order traversal of its nodes' values.
     (ie, from left to right, level by level).

    For example:
    Given binary tree {3,9,20,#,#,15,7},
        3
       / \
      9  20
        /  \
       15   7
    return its bottom-up level order traversal as:
    [
      [15,7],
      [9,20],
      [3]
    ]
    confused what "{1,#,2,3}" means?


    OJ's Binary Tree Serialization:
    The serialization of a binary tree follows a level order traversal,
     where '#' signifies a path terminator where no node exists below.

    Here's an example:
       1
      / \
     2   3
        /
       4
        \
         5
    The above binary tree is serialized as "{1,2,3,#,#,4,#,#,5}".

    https://leetcode.com/problems/binary-tree-level-order-traversal-ii/

\end{lstlisting}

\textbf{Solution}

~~ Just add a reversion on list among Problem 102 ``Binary Tree Level Order Traversal''

\javacode{Pro107}{Solution}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 103 Binary Tree Zigzag Level Order Traversal
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 103 Binary Tree Zigzag Level Order Traversal}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a binary tree, return the zigzag level order traversal
     of its nodes' values.
      (ie, from left to right, then right to left for the next level
       and alternate between).

    For example:
    Given binary tree {3,9,20,#,#,15,7},
        3
       / \
      9  20
        /  \
       15   7
    return its zigzag level order traversal as:
    [
      [3],
      [20,9],
      [15,7]
    ]

    https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/

\end{lstlisting}

\textbf{Solution}

~~ Not as complicated as what is said on Internet, similar to Problem 102 ``Binary Tree Level Order Traversal'', just to change the sequence of printing...

\javacode{Pro103}{Solution}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 100 Same Tree
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 100 Same Tree}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given two binary trees, write a function to check if they are equal or not.

    Two binary trees are considered equal if they are structurally identical
     and the nodes have the same value.

    https://leetcode.com/problems/same-tree/

\end{lstlisting}


\textbf{Solution}

~~Similar to Problem 101 ``Symmetric Tree'', except for the nodes for comparison.

\javacode{Pro100}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 101 Symmetric Tree
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 101 Symmetric Tree}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a binary tree, check whether it is a mirror of itself
     (ie, symmetric around its center).

    For example, this binary tree is symmetric:

        1
       / \
      2   2
     / \ / \
    3  4 4  3
    But the following is not:
        1
       / \
      2   2
       \   \
       3    3
    Note:
    Bonus points if you could solve it both recursively and iteratively.

    https://leetcode.com/problems/symmetric-tree/

\end{lstlisting}

\textbf{Solution 1}

~~ Recursion solution is kind of simple(but I still can't figure it out at first sight...).

\javacode{Pro101_1}{Solution 1}

\textbf{Solution 2}

~~ BFS solution by myself, given the fact that if the tree is symmetric, the indexes of nodes in pair must sum up to $2^{level}-1$, here level is the level in tree, root is 0, children of root is 1... index is its serial number from left to right, index of current node is 2*parent or 2*parent+1(depending on whether the node is on left side or right side.)

\javacode{Pro101_2_1}{Solution 2.1}

~~ Solution on Internet, much simpler than my solution...

\ccode{Pro101_2_2}{Solution 2.2}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 62 Unique Paths
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 62 Unique Paths}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    A robot is located at the top-left corner of a m * n grid
     (marked 'Start' in the diagram below).

    The robot can only move either down or right at any point in time.
     The robot is trying to reach the bottom-right corner of the grid
      (marked 'Finish' in the diagram below).

    Figure is shown below the description.

    How many possible unique paths are there?


    Above is a 3 * 7 grid. How many possible unique paths are there?

    Note: m and n will be at most 100.

    https://leetcode.com/problems/unique-paths/

\end{lstlisting}

\includegraphics[width=0.8\columnwidth]{figures/62_unique_paths}

\textbf{Solution}

~~ This is maybe the 1st dp problem I can solve by myself...

\javacode{Pro62}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 63 Unique Paths II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 63 Unique Paths II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Follow up for "Unique Paths":

    Now consider if some obstacles are added to the grids.
     How many unique paths would there be?

    An obstacle and empty space is marked as 1 and 0 respectively in the grid.

    For example,
    There is one obstacle in the middle of a 3x3 grid as illustrated below.

    [
      [0,0,0],
      [0,1,0],
      [0,0,0]
    ]
    The total number of unique paths is 2.

    Note: m and n will be at most 100.

    https://leetcode.com/problems/unique-paths-ii/

\end{lstlisting}

\includegraphics[width=0.8\columnwidth]{figures/62_unique_paths}

\textbf{Solution}

~~ Just add checking process to see if there are obstacles, if so, dp[i][j] = 0; Mention that in initialization phase(to initialize 1st row and 1st column), when we first met obstacle, the latter grids are all impassable, then dp value should be 0 too.

\javacode{Pro63}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 64 Minimum Path Sum
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 64 Minimum Path Sum}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a m x n grid filled with non-negative numbers,
     find a path from top left to bottom right which minimizes
      the sum of all numbers along its path.

    Note: You can only move either down or right at any point in time.

    https://leetcode.com/problems/minimum-path-sum/

\end{lstlisting}


\textbf{Solution}

~~A bit more complicated than Problem 62 ``Unique Paths'', see code in listing \ref{Pro64}

\javacode{Pro64}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 174 Dungeon Game
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 174 Dungeon Game}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    The demons had captured the princess (P) and imprisoned her
     in the bottom-right corner of a dungeon.
      The dungeon consists of M x N rooms laid out in a 2D grid.
       Our valiant knight (K) was initially positioned
        in the top-left room and must fight his way through
         the dungeon to rescue the princess.

    The knight has an initial health point represented by a positive integer.
     If at any point his health point drops to 0 or below, he dies immediately.

    Some of the rooms are guarded by demons, so the knight loses health
     (negative integers) upon entering these rooms;
      other rooms are either empty (0's) or contain magic orbs
       that increase the knight's health (positive integers).

    In order to reach the princess as quickly as possible,
     the knight decides to move only rightward or downward in each step.


    Write a function to determine the knight's minimum initial health
     so that he is able to rescue the princess.

    For example, given the dungeon below, the initial health of the knight
     must be at least 7 if he follows
      the optimal path RIGHT$->$ RIGHT $->$ DOWN $->$ DOWN.

     -----------------
    |-2(K)|  -3 |  3  |
    |-----------------|
    |  -5 |	-10 |  1  |
    |-----------------|
    | 10  |	30  |-5(P)|
     -----------------

    Notes:

    The knight's health has no upper bound.
    Any room can contain threats or power-ups,
     even the first room the knight enters
      and the bottom-right room where the princess is imprisoned.

    https://leetcode.com/problems/dungeon-game/

\end{lstlisting}


\textbf{Solution}

~~Much more complicated than Problems `Unique Path's. You'll find dynamic programming from top left corner is extremely difficult and confusing. Try start from the bottom right corner to get guaranteed health value. Another thing needs to be carefully taken into consideration is when doing DP calculation, since we are starting from bottom right corner(get guaranteed health), extra positive health are useless, since the Knight cannot respawn with extra health, we still need to guarantee his health of his previous steps, so 0 is enough.

\javacode{Pro174}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 232 Implement Queue using Stacks
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 232 Implement Queue using Stacks}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Implement the following operations of a queue using stacks.

    push(x) -- Push element x to the back of queue.
    pop() -- Removes the element from in front of queue.
    peek() -- Get the front element.
    empty() -- Return whether the queue is empty.

    Notes:
        You must use only standard operations of a stack
         -- which means only push to top, peek/pop from top, size,
          and is empty operations are valid.

        Depending on your language, stack may not be supported natively.
         You may simulate a stack by using a list or deque (double-ended queue),
          as long as you use only standard operations of a stack.

        You may assume that all operations are valid
         (for example, no pop or peek operations will be called on an empty queue).

    https://leetcode.com/problems/implement-queue-using-stacks/

\end{lstlisting}

\textbf{Solution}

~~ Use 2 containers to implement another kind of container, just see listings.

\javacode{Pro232}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 225 Implement Stack using Queues
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 225 Implement Stack using Queues}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Implement the following operations of a stack using queues.

    push(x) -- Push element x onto stack.
    pop() -- Removes the element on top of the stack.
    top() -- Get the top element.
    empty() -- Return whether the stack is empty.

    Notes:

        You must use only standard operations of a queue
         -- which means only push to back, peek/pop from front,
          size, and is empty operations are valid.

        Depending on your language, queue may not be supported natively.
         You may simulate a queue by using a list or deque (double-ended queue),
          as long as you use only standard operations of a queue.

        You may assume that all operations are valid
         (for example, no pop or top operations will be called on an empty stack).



    https://leetcode.com/problems/implement-queue-using-stacks/

\end{lstlisting}


\textbf{Solution}

~~ See listings.

\javacode{Pro225}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 148 Sort List
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 148 Sort List}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Sort a linked list in O(n log n) time using constant space complexity.

    https://leetcode.com/problems/sort-list/

\end{lstlisting}


\textbf{Solution}

~~ First, review all kinds of sorting methods!

\includegraphics[width=0.8\columnwidth]{figures/148_sort_list}

~~We can see that Heap sort, Quick sort and Merge sort satisfy the requirements of problem. They all need extra space at first sight, which may not meet the space requirement. However, when we look at the attribute of LinkedList, we can find out that we do not need to allocate extra space to store the sorted list after merging, what we need to do is just to reconnect the nodes.

\javacode{Pro148}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 147 Insertion Sort List
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 147 Insertion Sort List}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Sort a linked list using insertion sort.

    https://leetcode.com/problems/insertion-sort-list/

\end{lstlisting}


\textbf{Solution}

~~It's an easy but a complicated problem which is not easy to be bug-free.

\javacode{Pro147}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 86 Partition List
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 86 Partition List}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a linked list and a value x, partition it such that all nodes
     less than x come before nodes greater than or equal to x.

    You should preserve the original relative order of the nodes
     in each of the two partitions.

    For example,
    Given 1->4->3->2->5->2 and x = 3,
    return 1->2->2->4->3->5.

    https://leetcode.com/problems/partition-list/

\end{lstlisting}


\textbf{Solution}

~~Maintain 2 List, one for elements less than x, one for elements larger or equal to x, finally reconnect them.

\javacode{Pro86}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 136 Single Number
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 136 Single Number}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an array of integers, every element appears twice except for one.
     Find that single one.

    https://leetcode.com/problems/single-number/

\end{lstlisting}


\textbf{Solution 1}

~~Review the whole set of ``Single number(I/II/III)'', an interesting set of problems.

~~First solution is to use a Hashset, if the element appears once, add it into Set; if it has appeared, remove it from Set. Finally the only element remains in Set is the `Single Number'.

\javacode{Pro136_1}{Solution 1}

\textbf{Solution 2}

~~Bit manipulation is more proper to this SET of problems. Xor is the key to this problem. Apply xor to 2 same numbers will get the result 0, and since xor is commutative(a xor b = b xor a) and associative(a xor b xor c = a xor (b xor c)), xor all numbers will get the single number!

~~In fact, solution in next Problem ``Single Number II'' is more proper for this SET of problems.

\javacode{Pro136_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 137 Single Number II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 137 Single Number II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an array of integers, every element appears three times except for one.
     Find that single one.

    Note:
    Your algorithm should have a linear runtime complexity.
     Could you implement it without using extra memory?

    https://leetcode.com/problems/single-number-ii/

\end{lstlisting}


\textbf{Solution}

~~Solution 1 of Problem 136 ``Single Number'' is no longer suitable for this problem. Bit manipulation still works, but this time a bit complicated.

~~ E.g.: array consists of 1,2,2,2,3,3,3, namely 001 010 010 010 011 011 011, for units digit, there are four 1s, so the 1 is from the single number... Follow such train of thought, we can solve this problem.

\javacode{Pro137}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 260 Single Number III
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 260 Single Number III}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an array of numbers nums, in which exactly two elements appear
     only once and all the other elements appear exactly twice.
      Find the two elements that appear only once.

    For example:

    Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].

    Note:
    The order of the result is not important. So in the above example,
     [5, 3] is also correct.
    Your algorithm should run in linear runtime complexity.
     Could you implement it using only constant space complexity?

    https://leetcode.com/problems/single-number-iii/

\end{lstlisting}


\textbf{Solution}

~~The key to solve this problem if to separate the two single numbers into 2 different groups so that we can apply algorithm from `Single Number' to each group.

~~ How to achieve that? First we xor all numbers to get a result from which we can conclude a result that when the digit of the result is 1, it means that 2 single numbers are differ among this digit, so that in terms of all numbers, the number of 1 should be odd number(consisting 1 single number), so that we can group numbers with digit valued 1 and digit valued 0 on that digit into 2 groups. Finally apply xor algorithm to get the single number from each group.

\javacode{Pro260}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 282 Expression Add Operators
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 282 Expression Add Operators}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a string that contains only digits 0-9 and a target value,
     return all possibilities to add binary operators
      (not unary) +, -, or * between the digits so they evaluate to the target value.

    Examples:
    "123", 6 -> ["1+2+3", "1*2*3"]
    "232", 8 -> ["2*3+2", "2+3*2"]
    "105", 5 -> ["1*0+5","10-5"]
    "00", 0 -> ["0+0", "0-0", "0*0"]
    "3456237490", 9191 -> []

    https://leetcode.com/problems/expression-add-operators/

\end{lstlisting}


\textbf{Solution}

~~A good DFS problem.

~~ The difficulties focus on those edge cases(String startsWith 0 - 01 is illegal; length of remaining string) and how to deal with multiply operation. In this solution uses a `diff' to save previous result, for example, 1 - 2 * 3, previous result should be -1(1 - 2), but 1-2*3=-5, which means we should apply -1 - (-2) + (-2 *3), here diff = -2, namely previous number.

~~ However, when a new problem arise, I still can't get the solution method!

\javacode{Pro282}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 200 Number of Islands
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 200 Number of Islands}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a 2d grid map of '1's (land) and '0's (water),
     count the number of islands.
      An island is surrounded by water and is formed
       by connecting adjacent lands horizontally or vertically.
        You may assume all four edges of the grid are all surrounded by water.

    Example 1:

    11110
    11010
    11000
    00000
    Answer: 1

    Example 2:

    11000
    11000
    00100
    00011
    Answer: 3

    https://leetcode.com/problems/number-of-islands/

\end{lstlisting}


\textbf{Solution}

~~It's just a simple DFS problem...

\javacode{Pro200}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 287 Find the Duplicate Number
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 287 Find the Duplicate Number}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an array nums containing n + 1 integers where each integer
     is between 1 and n (inclusive),
      prove that at least one duplicate number must exist.
       Assume that there is only one duplicate number, find the duplicate one.

    Note:
    You must not modify the array (assume the array is read only).
    You must use only constant, O(1) extra space.
    Your runtime complexity should be less than O(n^2).
    There is only one duplicate number in the array,
     but it could be repeated more than once.

    https://leetcode.com/problems/find-the-duplicate-number/

\end{lstlisting}


\textbf{Solution 1}

~~ A pretty interesting problem.

~~ There is a good blog which shows all kinds of solutions for this problem,

~~ see \url{https://segmentfault.com/a/1190000003817671}.

~~Binary Search is available with its $O(n logn) runtime and O(1) space$, with the idea to binary search for the value from 1 to n to match numbers in array, instead of searching in the array itself.

\javacode{Pro287_1}{Solution 1}

\textbf{Solution 2}

~~An $O(n) runtime, O(1) space$ solution, fantastic train of thought!

~~ See http://keithschwarz.com/interesting/code/?dir=find-duplicate

~~ Main idea is like ``Find Linked List Cycle II'', use `slow = array[slow], fast = array[array[fast]]' mappings to check if there is a cycle and get the entry. The entry is exactly what we are looking for!(Since there is a array[i] = array[j], where i != j).

\javacode{Pro287_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 268 Missing Number
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 268 Missing Number}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an array containing n distinct numbers taken from
     0, 1, 2, ..., n, find the one that is missing from the array.

    For example,
    Given nums = [0, 1, 3] return 2.

    Note:
    Your algorithm should run in linear runtime complexity.
     Could you implement it using only constant extra space complexity?

    https://leetcode.com/problems/missing-number/

\end{lstlisting}


\textbf{Solution - Using Sum}

~~ Since there is only one missing element, the different between sum of the array and 0 to n is exactly what is missing.

~~ Binary search similar to Problem ``Find the Duplicate Number'' is also proper for this problem.(Remember to sort the array first if we don't want to calculate the count.)

\javacode{Pro268_1}{Solution 1}

\textbf{Solution - Mark Position}

~~ Solution 2 is to set up a new array, with a length more than 1 element of former array. In the new array, the elements are the same of (index + 1). Every time we find a number in old array, we set element in corresponding position in new array -1. Finally we iterate the new array, the element which is not changed to -1 is what we want.

~~ Some similar solutions including Using Hashset or sorted array to store the count of each number to see if there is a non-existing element.

\javacode{Pro268_2}{Solution 2}

\textbf{Solution - Bit Manipulation}

~~This solution is interesting. See the steps first.

\begin{enumerate}
  \item XOR all the array elements, let the result of XOR be X1.
  \item XOR all numbers from 1 to n, let XOR be X2.
  \item XOR of X1 and X2 gives the missing number.
\end{enumerate}

~~Feel familiar? The insight of these steps is exactly like ``Single Number'', or to be more specific, the characteristic of XOR operator.

\ccode{Pro268_3}{Solution 3}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 41 First Missing Positive
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 41 First Missing Positive}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an unsorted integer array, find the first missing positive integer.

    For example,
    Given [1,2,0] return 3,
    and [3,4,-1,1] return 2.

    Your algorithm should run in O(n) time and uses constant space.

    https://leetcode.com/problems/first-missing-positive/

\end{lstlisting}


\textbf{Solution}

~~ This is somewhat like the idea of radix sort, to put each element to where it should be(arr[idx] = idx), then the 1st grid which doesn't satisfy this attribute is exactly the number we want.

\javacode{Pro41_1}{Solution 1.1}

Below is a solution without reducing 1 to all elements.

\javacode{Pro41_2}{Solution 1.2}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 98 Validate Binary Search Tree
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 98 Validate Binary Search Tree}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a binary tree, determine if it is a valid binary search tree (BST).

    Assume a BST is defined as follows:

        The left subtree of a node contains
         only nodes with keys less than the node's key.
        The right subtree of a node contains
         only nodes with keys greater than the node's key.
        Both the left and right subtrees must
         also be binary search trees.

    https://leetcode.com/problems/validate-binary-search-tree/

\end{lstlisting}


\textbf{Solution 1}

~~ Plenty of methods to solve the problem. First solution is to use recursion to solve the problem.

~~ However, code on ``Clean Code Handbook'' is extremely clean and charming!

\javacode{Pro98_1}{Solution 1}

\textbf{Solution 2}

~~ A valid binary search tree has the attribute to keep ascending order when traversing the tree in an inorder order.

\javacode{Pro98_2}{Solution 2}



\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 150 Evaluate Reverse Polish Notation
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 150 Evaluate Reverse Polish Notation}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Evaluate the value of an arithmetic expression in Reverse Polish Notation.

    Valid operators are +, -, *, /.
     Each operand may be an integer or another expression.

    Some examples:
      ["2", "1", "+", "3", "*"] -$>$ ((2 + 1) * 3) $->$ 9
      ["4", "13", "5", "/", "+"] -$>$ (4 + (13 / 5)) $->$ 6

    https://leetcode.com/problems/evaluate-reverse-polish-notation/

\end{lstlisting}


\textbf{Solution 1}

~~ Reverse Polish expression evaluation is a standard stack problem, normally use stack to solve this.

\javacode{Pro150_1}{Solution 1}

\textbf{Solution 2}

~~ However, when we want to add a new operator, the structure now is not so extensive since we should modify two parts of program. Use a Map to extend the program(It's a solution followed in ``Clean Code Handbook''):

\javacode{Pro150_2}{Solution 2}



\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 130 Surrounded Regions
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 130 Surrounded Regions}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a 2D board containing 'X' and 'O', capture all regions surrounded by 'X'.

    A region is captured by flipping all 'O's into 'X's in that surrounded region.

    For example,
    X X X X
    X O O X
    X X O X
    X O X X
    After running your function, the board should be:

    X X X X
    X X X X
    X X X X
    X O X X

    https://leetcode.com/problems/surrounded-regions/

\end{lstlisting}


\textbf{Solution}

~~ DFS will get StackOverflowException, so use BFS to solve the problem.

~~ (Honestly, I don't know why my DFS solution StackOverflow?!)

\javacode{Pro130}{Solution}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 179 Largest Number
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 179 Largest Number}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a list of non negative integers, arrange them such that
     they form the largest number.

    For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330.

    Note: The result may be very large, so you need to return a string
     instead of an integer.

    https://leetcode.com/problems/largest-number/

\end{lstlisting}


\textbf{Solution}

~~ Re-design the compare to judge two strings(A tactic is when we want to get bigger one of s1 and s2, check relation between s1s2 and s2s1, e.g. `93' $>$ `39' so `9' $>$ `3')

~~ Don't forget the condition when result consists several 0s!

\javacode{Pro179}{Solution}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 224 Basic Calculator
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 224 Basic Calculator}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Implement a basic calculator to evaluate a simple expression string.

    The expression string may contain open ( and closing parentheses ),
     the plus + or minus sign -, non-negative integers and empty spaces .

    You may assume that the given expression is always valid.

    Some examples:
    "1 + 1" = 2
    " 2-1 + 2 " = 3
    "(1+(4+5+2)-3)+(6+8)" = 23

    https://leetcode.com/problems/basic-calculator/

\end{lstlisting}


\textbf{Solution}

~~ A complicated problem.... String evaluation...

~~ Reference: how to get Reverse Polish Expression :

\url{http://blog.csdn.net/signsmile/article/details/2877729}


\javacode{Pro224}{Solution}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 227 Basic Calculator II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 227 Basic Calculator II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Implement a basic calculator to evaluate a simple expression string.

    The expression string contains only non-negative integers,
     +, -, *, / operators and empty spaces .
      The integer division should truncate toward zero.

    You may assume that the given expression is always valid.

    Some examples:
    "3+2*2" = 7
    " 3/2 " = 1
    " 3+5 / 2 " = 5

    Note: Do not use the eval built-in library function.

    https://leetcode.com/problems/climbing-stairs/

\end{lstlisting}


\textbf{Solution}

~~A more complicated ``Basic Calculator'', calculate numbers in stack first whose priority is not larger than current operator to push.(e.g.: when current operator to push is *, calculate until the operator on peek of stack is +/-; if the current operator is +/-, calculate all elements in stack.


\javacode{Pro227}{Solution}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 25 Reverse Nodes in k-Group
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 25 Reverse Nodes in k-Group}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a linked list, reverse the nodes of a linked list k
     at a time and return its modified list.

    If the number of nodes is not a multiple of k then left-out nodes
     in the end should remain as it is.

    You may not alter the values in the nodes, only nodes
     itself may be changed.

    Only constant memory is allowed.

    For example,
    Given this linked list: 1->2->3->4->5

    For k = 2, you should return: 2->1->4->3->5

    For k = 3, you should return: 3->2->1->4->5

    https://leetcode.com/problems/reverse-nodes-in-k-group/

\end{lstlisting}


\textbf{Solution}

~~A bad news is that I debugged it in my Eclipse IDE........


\javacode{Pro25}{Solution}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 70 Climbing Stairs
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 70 Climbing Stairs}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    You are climbing a stair case. It takes n steps to reach to the top.

    Each time you can either climb 1 or 2 steps.
     In how many distinct ways can you climb to the top?

    https://leetcode.com/problems/climbing-stairs/

\end{lstlisting}


\textbf{Solution}

~~A simple dp problem, so similar to Fibonacci problem.


\javacode{Pro70}{Solution}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 3 Longest Substring Without Repeating Characters
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 3 Longest Substring Without Repeating Characters}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a string, find the length of the longest substring
     without repeating characters.
      For example, the longest substring without repeating letters
       for "abcabcbb" is "abc", which the length is 3.
        For "bbbbb" the longest substring is "b",
         with the length of 1.

    https://leetcode.com/problems/longest-substring-without-repeating-characters/

\end{lstlisting}


\textbf{Solution}

~~Brute force will have $O(n^2) runtime$ complexity, which will get TLE.

~~ So using a clever way of thought. Maintain 2 pointers, one point to the start of sequence while another point to end of sequence. A array of boolean is used to check if current character has exists in previous sequence. If current character doesn't exists, well good news, we can continue iterating and check if we've got the longest subsequence; if it exists, iterate start pivot to recover the states of those characters, make them as they have not been visited, until meet the character same as current character, rearrange the position of pointer, continue iterating.

~~ Don't forget to check if the sequence at end of whole String is the longest.

\javacode{Pro3}{Solution}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 96 Unique Binary Search Trees
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 96 Unique Binary Search Trees}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given n, how many structurally unique BST's (binary search trees)
     that store values 1...n?

    For example,
    Given n = 3, there are a total of 5 unique BST's.

       1         3     3      2      1
        \       /     /      / \      \
         3     2     1      1   3      2
        /     /       \                 \
       2     1         2                 3

    https://leetcode.com/problems/unique-binary-search-trees/

\end{lstlisting}


\textbf{Solution}

~~A picture will be good for our understanding of this problem.

~~\includegraphics[width=0.8\columnwidth]{figures/96_unique_binary_search_trees}

\javacode{Pro96}{Solution}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 95 Unique Binary Search Trees II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 95 Unique Binary Search Trees II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given n, generate all structurally unique BST's (binary search trees)
     that store values 1...n.

    For example,
    Given n = 3, your program should return all 5 unique BST's shown below.

       1         3     3      2      1
        \       /     /      / \      \
         3     2     1      1   3      2
        /     /       \                 \
       2     1         2                 3

    https://leetcode.com/problems/unique-binary-search-trees-ii/

\end{lstlisting}


\textbf{Solution}

~~This is an interesting recursion problem since we can return a set of solutions to iteratively add them to left side and right side onto root node.

~~ There are many other problems which set left and right children recursively.

\javacode{Pro95}{Solution}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 241 Different Ways to Add Parentheses
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 241 Different Ways to Add Parentheses}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a string of numbers and operators, return all possible results
     from computing all the different possible ways to
      group numbers and operators.
       The valid operators are +, - and *.


    Example 1
    Input: "2-1-1".

    ((2-1)-1) = 0
    (2-(1-1)) = 2
    Output: [0, 2]


    Example 2
    Input: "2*3-4*5"

    (2*(3-(4*5))) = -34
    ((2*3)-(4*5)) = -14
    ((2*(3-4))*5) = -10
    (2*((3-4)*5)) = -10
    (((2*3)-4)*5) = 10
    Output: [-34, -14, -10, -10, 10]

    https://leetcode.com/problems/different-ways-to-add-parentheses/

\end{lstlisting}


\textbf{Solution}

~~The train of thought is similar to Problem ``Unique Binary Search Tree II'', get all possibilities, and combine them all.

\javacode{Pro241}{Solution}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 129 Sum Root to Leaf Numbers
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 129 Sum Root to Leaf Numbers}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a binary tree containing digits from 0-9 only,
     each root-to-leaf path could represent a number.

    An example is the root-to-leaf path 1->2->3 which represents the number 123.

    Find the total sum of all root-to-leaf numbers.

    For example,

        1
       / \
      2   3
    The root-to-leaf path 1->2 represents the number 12.
    The root-to-leaf path 1->3 represents the number 13.

    Return the sum = 12 + 13 = 25.

    https://leetcode.com/problems/sum-root-to-leaf-numbers/

\end{lstlisting}


\textbf{Solution}

~~A DFS question, mention the edge cases.

\javacode{Pro129}{Solution}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 173 Binary Search Tree Iterator
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 173 Binary Search Tree Iterator}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Implement an iterator over a binary search tree (BST).
     Your iterator will be initialized with the root node of a BST.

    Calling next() will return the next smallest number in the BST.

    Note: next() and hasNext() should run in average
     O(1) time and uses O(h) memory, where h is the height of the tree.

    https://leetcode.com/problems/binary-search-tree-iterator/

\end{lstlisting}


\textbf{Solution}

~~BST is really a tactical data structure. Iterator asks us to return the next smallest element, namely return a ascending list if we call the next() function several times. Recall something? The inorder traversal of BST! Then what we only need to do is to repeat what we have done in process of inorder traversal.

\javacode{Pro173}{Solution}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 297 Serialize and Deserialize Binary Tree
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 297 Serialize and Deserialize Binary Tree}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Serialization is the process of converting a data structure or object into
     a sequence of bits so that it can be stored in a file or memory buffer,
      or transmitted across a network connection link to be reconstructed later
       in the same or another computer environment.

    Design an algorithm to serialize and deserialize a binary tree.
     There is no restriction on how your serialization/deserialization algorithm
      should work. You just need to ensure that a binary tree can be serialized to
       a string and this string can be deserialized to the original tree structure.

    For example, you may serialize the following tree

        1
       / \
      2   3
         / \
        4   5
    as "[1,2,3,null,null,4,5]", just the same as how LeetCode OJ
     serializes a binary tree. You do not necessarily need to follow this format,
      so please be creative and come up with different approaches yourself.
    Note: Do not use class member/global/static variables to store states.
     Your serialize and deserialize algorithms should be stateless.

    https://leetcode.com/problems/serialize-and-deserialize-binary-tree/

\end{lstlisting}


\textbf{Solution}

~~Honestly, my solution is not perfect at all(or to say not good at all) since I serialize all elements including null, which is different from LeetCode OJ.

\javacode{Pro297}{Solution}



\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 284 Peeking Iterator
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 284 Peeking Iterator}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an Iterator class interface with methods: next() and hasNext(),
     design and implement a PeekingIterator that support the peek() operation
      -- it essentially peek() at the element
       that will be returned by the next call to next().

    Here is an example. Assume that the iterator is initialized
     to the beginning of the list: [1, 2, 3].

    Call next() gets you 1, the first element in the list.

    Now you call peek() and it returns 2, the next element.
     Calling next() after that still return 2.

    You call next() the final time and it returns 3, the last element.
     Calling hasNext() after that should return false.

    Hint:

    Think of "looking ahead". You want to cache the next element.
    Is one variable sufficient? Why or why not?
    Test your design with call order of peek() before next() vs next() before peek().
    For a clean implementation, check out Google's guava library source code.
    Follow up: How would you extend your design to be generic and work with all types,
     not just integer?

    https://leetcode.com/problems/serialize-and-deserialize-binary-tree/

\end{lstlisting}


\textbf{Solution}

~~My solution is copied from guava source code in some extent, so I will list the standard solution here in Solution 1.2.

\javacode{Pro284_1}{Solution 1.1}

\javacode{Pro284_2}{Solution 1.2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 226 Invert Binary Tree
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 226 Invert Binary Tree}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Invert a binary tree.

         4
       /   \
      2     7
     / \   / \
    1   3 6   9
    to
         4
       /   \
      7     2
     / \   / \
    9   6 3   1
    Trivia:
    This problem was inspired by this original tweet by Max Howell:
    Google: 90\% of our engineers use the software you wrote (Homebrew),
     but you can't invert a binary tree on a whiteboard so fuck off.

    https://leetcode.com/problems/invert-binary-tree/

\end{lstlisting}


\textbf{Solution 1}

~~A simple problem. Solution 1 is recursive solution.

\javacode{Pro226_1}{Solution 1}

\textbf{Solution 2}

~~ Solution 2 is an iterative solution.

\javacode{Pro226_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 257 Binary Tree Paths
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 257 Binary Tree Paths}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a binary tree, return all root-to-leaf paths.

    For example, given the following binary tree:

       1
     /   \
    2     3
     \
      5
    All root-to-leaf paths are:

    ["1->2->5", "1->3"]

    https://leetcode.com/problems/binary-tree-paths/

\end{lstlisting}


\textbf{Solution}

~~A recursive problem.

\javacode{Pro257}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 144 Binary Tree Preorder Traversal
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 144 Binary Tree Preorder Traversal}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a binary tree, return the preorder traversal of its nodes' values.

    For example:
    Given binary tree {1,#,2,3},
       1
        \
         2
        /
       3
    return [1,2,3].

    Note: Recursive solution is trivial, could you do it iteratively?

    https://leetcode.com/problems/binary-tree-preorder-traversal/

\end{lstlisting}


\textbf{Solution 1}

~~First come up with the recursive solution.

\javacode{Pro144_1}{Solution 1}

\textbf{Solution 2}

~~In description, we are asked to finish this task in an iterative way, so we should consider it carefully. Preorder traversal is the easiest traversal in terms of coding. Using a stack to store nodes visited, but remember to push right child first so that in stack they will be popped after left child.

\javacode{Pro144_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 94 Binary Tree Inorder Traversal
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 94 Binary Tree Inorder Traversal}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a binary tree, return the inorder traversal of its nodes' values.

    For example:
    Given binary tree {1,#,2,3},
       1
        \
         2
        /
       3
    return [1,3,2].

    Note: Recursive solution is trivial, could you do it iteratively?

    https://leetcode.com/problems/binary-tree-inorder-traversal/

\end{lstlisting}


\textbf{Solution 1}

~~First come up with the recursive solution.

\javacode{Pro94_1}{Solution 1}

\textbf{Solution 2}

~~For iterative solution, we use a stack to maintain the order of nodes. This time a bit different- we first push all left nodes of root node iteratively, and when we pop out a TreeNode, after adding the value into result list, we should push right child of current node and all its left children into stack.

\javacode{Pro94_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 145 Binary Tree Postorder Traversal
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 145 Binary Tree Postorder Traversal}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a binary tree, return the postorder traversal of its nodes' values.

    For example:
    Given binary tree {1,#,2,3},
       1
        \
         2
        /
       3
    return [3,2,1].

    Note: Recursive solution is trivial, could you do it iteratively?

    https://leetcode.com/problems/binary-tree-postorder-traversal/

\end{lstlisting}


\textbf{Solution 1}

~~First come up with the recursive solution.

\javacode{Pro145_1}{Solution 1}

\textbf{Solution 2}

~~Postorder traversal is more complicated than preorder and inorder. Its complexity lays in the fact that when we first pop the node, we should not print it immediately but should wait for all its children to be resolved, so we shall set a tag to check if the node is visited, if not, push its children into stack and mark the parent node as visited. So when the next time we meet, we can directly put it into our result list.

\javacode{Pro145_2_1}{Solution 2.1}

~~Another interesting solution is to reverse the result since postorder leads to (left, right, root), when we reverse it, it appears to be (root, right, left), which is so similar to preorder traversal.

\javacode{Pro145_2_2}{Solution 2.2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 199 Binary Tree Right Side View
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 199 Binary Tree Right Side View}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a binary tree, imagine yourself standing on the right side of it,
     return the values of the nodes you can see ordered from top to bottom.

    For example:
    Given the following binary tree,
       1            <---
     /   \
    2     3         <---
     \     \
      5     4       <---
    You should return [1, 3, 4].

    https://leetcode.com/problems/binary-tree-postorder-traversal/

\end{lstlisting}


\textbf{Solution}

~~BFS problem, add value of rightmost node for each level to get the right side view.

\javacode{Pro199}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 116 Populating Next Right Pointers in Each Node
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 116 Populating Next Right Pointers in Each Node}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a binary tree

    struct TreeLinkNode {
      TreeLinkNode *left;
      TreeLinkNode *right;
      TreeLinkNode *next;
    }
    Populate each next pointer to point to its next right node.
     If there is no next right node, the next pointer should be set to NULL.

    Initially, all next pointers are set to NULL.

    Note:

    You may only use constant extra space.
    You may assume that it is a perfect binary tree
     (ie, all leaves are at the same level, and every parent has two children).
    For example,
    Given the following perfect binary tree,
             1
           /  \
          2    3
         / \  / \
        4  5  6  7
    After calling your function, the tree should look like:
             1 -> NULL
           /  \
          2 -> 3 -> NULL
         / \  / \
        4->5->6->7 -> NULL

    https://leetcode.com/problems/populating-next-right-pointers-in-each-node/

\end{lstlisting}


\textbf{Solution}

~~Similar to Problem ``Binary Tree Right Side View'', use BFS.

\javacode{Pro116}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 117 Populating Next Right Pointers in Each Node II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 117 Populating Next Right Pointers in Each Node II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Follow up for problem "Populating Next Right Pointers in Each Node".

    What if the given tree could be any binary tree?
     Would your previous solution still work?

    Note:

    You may only use constant extra space.
    For example,
    Given the following binary tree,
             1
           /  \
          2    3
         / \    \
        4   5    7
    After calling your function, the tree should look like:
             1 -> NULL
           /  \
          2 -> 3 -> NULL
         / \    \
        4-> 5 -> 7 -> NULL

    https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/

\end{lstlisting}


\textbf{Solution}

~~$O(1) space$ is a big challenge. If the tree is a perfect binary tree, an interesting way is to connect left child and right child of each node, and when current node has a next object not pointing to null, connect right child of current node to left child of next node of current node.

~~However, it is said that the tree is just a common binary tree, things seems a bit more complicated, we shall consider all kinds of circumstances and edge cases, following former train of thought.

\javacode{Pro117}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 105 Construct Binary Tree from Preorder and Inorder Traversal
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 105 Construct Binary Tree from Preorder and Inorder Traversal}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given preorder and inorder traversal of a tree, construct the binary tree.

    https://leetcode.com/problems/-
            construct-binary-tree-from-preorder-and-inorder-traversal/

\end{lstlisting}


\textbf{Solution}

~~How to split the two arrays is a important stuff to consider, recursion is a natural way to achieve this.

\javacode{Pro105}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 106 Construct Binary Tree from Inorder and Postorder Traversal
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 106 Construct Binary Tree from Inorder and Postorder Traversal}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given inorder and postorder traversal of a tree, construct the binary tree.

    Note:
    You may assume that duplicates do not exist in the tree.

    https://leetcode.com/problems/-
            construct-binary-tree-from-inorder-and-postorder-traversal/

\end{lstlisting}


\textbf{Solution}

~~Similar to Problem 105 ``Construct Binary Tree from Preorder and Inorder Traversal''.

\javacode{Pro106}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 242 Valid Anagram
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 242 Valid Anagram}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given two strings s and t, write a function to determine
     if t is an anagram of s.

    For example,
    s = "anagram", t = "nagaram", return true.
    s = "rat", t = "car", return false.

    Note:
    You may assume the string contains only lowercase alphabets.

    Follow up:
    What if the inputs contain unicode characters?
     How would you adapt your solution to such case?

    https://leetcode.com/problems/valid-anagram/

\end{lstlisting}


\textbf{Solution}

~~For ascii characters, maintain 2 arrays containing appearing count for each letter. As for the follow up, can extending the range of array to 65535 work?

~~ Well, there is another solution which uses sorting method. s.toCharArray() then Arrays.sort to see if sorted s and sorted t are equal............

\javacode{Pro242}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 49 Group Anagrams
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 49 Group Anagrams}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an array of strings, group anagrams together.

    For example, given: ["eat", "tea", "tan", "ate", "nat", "bat"],
    Return:

    [
      ["ate", "eat","tea"],
      ["nat","tan"],
      ["bat"]
    ]
    Note:
    For the return value, each inner list's elements
     must follow the lexicographic order.
    All inputs will be in lower-case.

    https://leetcode.com/problems/anagrams/

\end{lstlisting}


\textbf{Solution}

~~ I think the solution is somewhat opportunistic... Use Arrays.sort to serve as the fundamental part of the whole program...

~~ However, when I was looking for a more proper solution in the Discuss section, I found that most solutions are of the same trains of thought. In fact, the key insight of solution is not the sorting of charArray but finding a proper hashcode for the Hashmap which stores each group. We may use expressions like ``a2b3'' to represent each word(don't forget to arrange the order of each letter).

~~ There is another optimal point to check length of each word, words with same length will never be anagrams.

\javacode{Pro49}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 112 Path Sum
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 112 Path Sum}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a binary tree and a sum, determine if the tree has a
     root-to-leaf path such that adding up all the values along
      the path equals the given sum.

    For example:
    Given the below binary tree and sum = 22,
                  5
                 / \
                4   8
               /   / \
              11  13  4
             /  \      \
            7    2      1
    return true, as there exist a root-to-leaf path 5->4->11->2
     which sum is 22.

    https://leetcode.com/problems/path-sum/

\end{lstlisting}


\textbf{Solution}

~~DFS, bring remaining sum into parameter.

\javacode{Pro112}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 113 Path Sum II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 113 Path Sum II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a binary tree and a sum, find all root-to-leaf paths
     where each path's sum equals the given sum.

    For example:
    Given the below binary tree and sum = 22,
                  5
                 / \
                4   8
               /   / \
              11  13  4
             /  \    / \
            7    2  5   1
    return
    [
       [5,4,11,2],
       [5,8,4,5]
    ]

    https://leetcode.com/problems/path-sum-ii/

\end{lstlisting}


\textbf{Solution}

~~I'm using a new ArrayList to do the dfs since List may be changed during recursion. I don't think this is necessary.

\javacode{Pro113}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 110 Balanced Binary Tree
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 110 Balanced Binary Tree}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a binary tree, determine if it is height-balanced.

    For this problem, a height-balanced binary tree
     is defined as a binary tree in which the depth of
      the two subtrees of every node never differ by more than 1.

    https://leetcode.com/problems/balanced-binary-tree/

\end{lstlisting}


\textbf{Solution 1}

~~Use maxDepth to see, use a top down recursion, though with $O(n^2) runtime$ complexity.

~~ Be aware of the importance of short-circuit logic

\javacode{Pro110_1}{Solution 1}

\textbf{Solution 2}

~~Another solution is from ``Clean Code Handbook''. A bottom-up recursion, use -1 to indicate that the subtree is already proved non-balanced.

\javacode{Pro110_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 230 Kth Smallest Element in a BST
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 230 Kth Smallest Element in a BST}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a binary search tree, write a function kthSmallest
     to find the kth smallest element in it.

    Note:
    You may assume k is always valid, 1 <= k <= BST's total elements.

    Follow up:
    What if the BST is modified (insert/delete operations)
     often and you need to find the kth smallest frequently?
      How would you optimize the kthSmallest routine?

    Hint:

    Try to utilize the property of a BST.
    What if you could modify the BST node's structure?
    The optimal runtime complexity is O(height of BST).

    https://leetcode.com/problems/kth-smallest-element-in-a-bst/

\end{lstlisting}


\textbf{Solution 1}

~~My first solution is to use inorder traversal since the result of such traversal is a list in order, I can easily pick out the kth one, which is what I want. However, it cannot solve the follow up problem(or adding values in the sorted list), neither can it be called a `clean'    code and has the optimized complexity of $O(height of BST) time$.

\javacode{Pro230_1}{Solution 1}

\textbf{Solution 2}

~~However, the problem is definitely a standard binary-search like problem. By judging node number of left subtree and right subtree, we can determine which subtree can be used to continue searching.

~~ More information about the train of thought, see

\includegraphics[width=0.75\columnwidth]{figures/230_kth_smallest_element_in_a_BST}

\javacode{Pro230_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 278 First Bad Version
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 278 First Bad Version}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    You are a product manager and currently leading a team to develop a new product.
     Unfortunately, the latest version of your product fails the quality check.
      Since each version is developed based on the previous version,
       all the versions after a bad version are also bad.

    Suppose you have n versions [1, 2, ..., n] and you want to
     find out the first bad one, which causes all the following ones to be bad.

    You are given an API bool isBadVersion(version)
     which will return whether version is bad.
      Implement a function to find the first bad version.
       You should minimize the number of calls to the API.

    https://leetcode.com/problems/first-bad-version/

\end{lstlisting}


\textbf{Solution}

~~A very simple binary search problem, BUT! use ``mid = low + (high - low) / 2;'' instead of ``mid = (low + high) / 2;'' since it may overflow to be negative so that the loop will never end.

\javacode{Pro278}{Solution}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 74 Search a 2D Matrix
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 74 Search a 2D Matrix}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Write an efficient algorithm that searches for a value in an m x n matrix.
     This matrix has the following properties:

    Integers in each row are sorted from left to right.
    The first integer of each row is greater than the last integer of the previous row.
    For example,

    Consider the following matrix:

    [
      [1,   3,  5,  7],
      [10, 11, 16, 20],
      [23, 30, 34, 50]
    ]
    Given target = 3, return true.

    https://leetcode.com/problems/search-a-2d-matrix/

\end{lstlisting}


\textbf{Solution}

~~Starting from [0,0] is very difficult to solve the problem since when we've got a larger element, we can go both downward and to the right. Starting from the top right corner. If current element is less than target, go to the left side; if larger, go downward.

~~I've missed the condition that `The first integer of each row is greater than the last integer of the previous row.' So I'm using the solution which also goes for the next Problem ``Search a 2D Matrix II''.

\javacode{Pro74}{Solution}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 240 Search a 2D Matrix II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 240 Search a 2D Matrix II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Write an efficient algorithm that searches for a value in an m x n matrix.
     This matrix has the following properties:

    Integers in each row are sorted in ascending from left to right.
    Integers in each column are sorted in ascending from top to bottom.
    For example,

    Consider the following matrix:

    [
      [1,   4,  7, 11, 15],
      [2,   5,  8, 12, 19],
      [3,   6,  9, 16, 22],
      [10, 13, 14, 17, 24],
      [18, 21, 23, 26, 30]
    ]
    Given target = 5, return true.

    Given target = 20, return false.

    https://leetcode.com/problems/search-a-2d-matrix-ii/

\end{lstlisting}


\textbf{Solution}

~~Since I've used the method to solve the previous problem, I won't spend too many words here explaining it.

\javacode{Pro204}{Solution}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 99 Recover Binary Search Tree
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 99 Recover Binary Search Tree}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Two elements of a binary search tree (BST) are swapped by mistake.

    Recover the tree without changing its structure.

    Note:
    A solution using O(n) space is pretty straight forward.
     Could you devise a constant space solution?

    https://leetcode.com/problems/recover-binary-search-tree/

\end{lstlisting}


\textbf{Solution 1}

~~Regardless of the problem requirements of $O(1) space$, the problem can be solved using inorder traversal since for BST, the inorder traversal list should be ascending, so if there is one or two mistaken parts, we should swap the values of nodes.

\javacode{Pro99_1}{Solution 1}

\textbf{Solution 2}

~~Since the requirement is $O(1) space$, we need to think something strange to us -- the Morris traversal. See figures:

\includegraphics[width=0.75\columnwidth]{figures/99_recover_binary_search_tree_1}

\includegraphics[width=0.75\columnwidth]{figures/99_recover_binary_search_tree_2}

\includegraphics[width=0.75\columnwidth]{figures/99_recover_binary_search_tree_3}

~~ So simulating the process is the key to achieve this. In the algorithm, when we want to `print', it means it's the time for us to refresh the value of previous node and make the check if the array is still sorted.


\javacode{Pro99_2}{Solution 2}

\textbf{Solution 3}

~~ And a recursion solution ... I can hardly understand it.

\ccode{Pro99_3}{Solution 3}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 235 Lowest Common Ancestor of a Binary Search Tree
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 235 Lowest Common Ancestor of a Binary Search Tree}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a binary search tree (BST), find the lowest common ancestor
     (LCA) of two given nodes in the BST.

    According to the definition of LCA on Wikipedia:
     The lowest common ancestor is defined between
      two nodes v and w as the lowest node in T that has
       both v and w as descendants (where we allow a node
        to be a descendant of itself).

            _______6______
           /              \
        ___2__          ___8__
       /      \        /      \
       0      _4       7       9
             /  \
             3   5
    For example, the lowest common ancestor (LCA) of
     nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2,
      since a node can be a descendant of itself according to the LCA definition.

    https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

\end{lstlisting}

\textbf{Solution 1}

~~LCA is a typical kind of problem. If possible, review Tarjan \& find-union.

~~First solution makes use of the characteristics of binary SEARCH tree, when finding the lowest ancestor, the value of the ancestor node v\_an should be v\_min $<=$ v\_an $<=$ v\_max.

\javacode{Pro235_1}{Solution 1}

\textbf{Solution 2}

~~Solution use the path to solve the problem. Still, we are using the feature of BST. In the next problem we will show a more general algorithm which can be applied to Binary tree.

\javacode{Pro235_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 236 Lowest Common Ancestor of a Binary Tree
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 236 Lowest Common Ancestor of a Binary Tree}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a binary tree, find the lowest common ancestor (LCA)
     of two given nodes in the tree.

    According to the definition of LCA on Wikipedia:
     The lowest common ancestor is defined between
      two nodes v and w as the lowest node in T that has
       both v and w as descendants (where we allow a node
        to be a descendant of itself).
            _______3______
           /              \
        ___5__          ___1__
       /      \        /      \
       6      _2       0       8
             /  \
             7   4
    For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3.
     Another example is LCA of nodes 5 and 4 is 5,
      since a node can be a descendant of itself according to the LCA definition.

    https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/

\end{lstlisting}

\textbf{Solution 1}

~~Since this is just a binary tree, we can only use the characteristic that the two target nodes are respectively at the left and right subtree of their LCA. It's a bottom-up solution.

\javacode{Pro236_1}{Solution 1}

\textbf{Solution 2}

~~Still, use path to check LCA, but this time a little complicated.


\javacode{Pro236_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 222 Count Complete Tree Nodes
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 222 Count Complete Tree Nodes}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a complete binary tree, count the number of nodes.

    Definition of a complete binary tree from Wikipedia:
    In a complete binary tree every level, except possibly the last,
     is completely filled, and all nodes in the last level
      are as far left as possible.
       It can have between 1 and 2h nodes inclusive at the last level h.

    https://leetcode.com/problems/count-complete-tree-nodes/

\end{lstlisting}

\textbf{Solution 1}

~~Recursive solution. Firstly, simply applying recursion to check all nodes in $O(n) time$ will get TLE, so we need optimization. Given the tree is a complete binary tree, then when left height of left subtree equals to right height of right subtree, the tree is a full binary tree, so the number of nodes can be worked out easily through $2^{height} - 1$.

~~ Note: this is not enough. Using inefficient function like `Math.pow' will still get TLE, use $1 << height$ instead.

~~ Besides, there is another thing we can optimize is to save the depth of subtree calculated since when we move curNode to its left child, the height of the new left subtree is height(former) - 1, unnecessary to calculate again.

\javacode{Pro222_1}{Solution 1}

\textbf{Solution 2}

~~Iterative solution from \url{https://segmentfault.com/a/1190000003818177}. Look at the left maximum height of left subtree and right subtree, if left equals right, then left tree is full, the end node is at the right subtree and if left is larger, it means that the end node is in left subtree.


\javacode{Pro222_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 108 Convert Sorted Array to Binary Search Tree
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 108 Convert Sorted Array to Binary Search Tree}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a complete binary tree, count the number of nodes.

    Given an array where elements are sorted in ascending order,
     convert it to a height balanced BST.

    https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/

\end{lstlisting}

\textbf{Solution}

~~A binary search problem. Root node is the middle element where left subtree and right subtree are formed from elements from both sides of middle elements.

\javacode{Pro108}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 109 Convert Sorted List to Binary Search Tree
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 109 Convert Sorted List to Binary Search Tree}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a singly linked list where elements are sorted in ascending order,
     convert it to a height balanced BST.

    https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/

\end{lstlisting}

\textbf{Solution}

~~Certainly we can use the solution in previous ``Convert Sorted Array to Binary Search Tree'', however, it will cost us extra runtime to get the middle element of list(in array, finding a element is of $O(1) runtime$).

~~ So we go for another direction. We can find out that the sorted list is exactly what an inorder traversal of a tree looks like, so we transform the print(or other) operations with iterating the list and form a rootNode.

~~ There is another problem which is related but (much?) more difficult than this one, of ``Convert Binary Search Tree (BST) to Sorted Doubly-Linked List'', worth pondering.

~~ See \url{http://articles.leetcode.com/convert-binary-search-tree-bst-to/}

\javacode{Pro109}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 114 Flatten Binary Tree to Linked List
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 114 Flatten Binary Tree to Linked List}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a binary tree, flatten it to a linked list in-place.

    For example,
    Given

             1
            / \
           2   5
          / \   \
         3   4   6
    The flattened tree should look like:
       1
        \
         2
          \
           3
            \
             4
              \
               5
                \
                 6


    Hints:
    If you notice carefully in the flattened tree,
     each node's right child points to the next node of a pre-order traversal.

    https://leetcode.com/problems/flatten-binary-tree-to-linked-list/

\end{lstlisting}

\textbf{Solution}

~~The solution of this one is in fact direct. We can easily notice that the new tree structure follows the preorder traversal order. Then we just:

~~\begin{enumerate}
    \item check if curNode.left == null, if not, recurse on its right node(since in preorder traversal, right node comes latter from root node)
    \item  if curNode.left != null, then left child should be the next element in preorder traversal, so root.left = null, root.right = formerLeft. BUT what about the former right node? Remember that former right node always follows after all nodes in left subtree of rootNode when doing preorder traversal, so we just append them to the right child of the rightMost node of formerLeft(namely current root.right).
    \item repeat 1 \& 2
\end{enumerate}

\javacode{Pro114}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 341 Flatten Nested List Iterator
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 341 Flatten Nested List Iterator}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a nested list of integers, implement an iterator to flatten it.

    Each element is either an integer, or a list --
     whose elements may also be integers or other lists.

    Example 1:
    Given the list [[1,1],2,[1,1]],

    By calling next repeatedly until hasNext returns false,
    the order of elements returned by next should be: [1,1,2,1,1].

    Example 2:
    Given the list [1,[4,[6]]],

    By calling next repeatedly until hasNext returns false,
     the order of elements returned by next should be: [1,4,6].

    https://leetcode.com/problems/flatten-nested-list-iterator/

\end{lstlisting}

\textbf{Solution}

~~Seemingly I list 2 solutions here, they are in nature similar, the difference just lies in when we flatten the list(to flatten the whole list or flatten it every time we pop an element out of the stack.)

\javacode{Pro341_1_1}{Solution - Flatten it using Stack}

\javacode{Pro341_1_2}{Solution - Flatten the whole list at first sight}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 50 Pow(x, n)
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 50 Pow(x, n)}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Implement pow(x, n).

    https://leetcode.com/problems/powx-n/

\end{lstlisting}

\textbf{Solution}

~~Implementing using for loop will get TLE(I can hardly imagine how slow loops can be). Moreover, the edge cases are pretty interesting.

~~ So use the formula in figure:

~~\includegraphics[width=0.75\columnwidth]{figures/50_power(x,n)}

~~ Lots of things to consider!! BTW, use n $>>>$ 1, not n $>>$ 1 to substitute n / 2.

\javacode{Pro50}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 69 Sqrt(x)
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 69 Sqrt(x)}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Implement int sqrt(int x).

    Compute and return the square root of x.

    https://leetcode.com/problems/sqrtx/

\end{lstlisting}

\textbf{Solution}

~~Brute force will definitely TLE. Use binary search to solve the problem. Be aware of the final result returned. For example, sqrt(3) = 1, but $1 * 1 = 1 < 3 (3 / 1 > 1)$

\javacode{Pro69}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 65 Valid Number
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 65 Valid Number}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Validate if a given string is numeric.

    Some examples:
    "0" => true
    " 0.1 " => true
    "abc" => false
    "1 a" => false
    "2e10" => true
    Note: It is intended for the problem statement to be ambiguous.
     You should gather all requirements up front before implementing one.

    https://leetcode.com/problems/valid-number/

\end{lstlisting}

\textbf{Solution}

~~RIts difficulty lies in so many edge cases of the problem.

\javacode{Pro65}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 124 Binary Tree Maximum Path Sum
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 124 Binary Tree Maximum Path Sum}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a binary tree, find the maximum path sum.

    For this problem, a path is defined as any sequence of nodes from some
     starting node to any node in the tree along the parent-child connections.
      The path does not need to go through the root.

    For example:
    Given the below binary tree,

           1
          / \
         2   3
    Return 6.

    https://leetcode.com/problems/binary-tree-maximum-path-sum/

\end{lstlisting}

\textbf{Solution}

~~ It's hard to distinguish whether the problem is hard or not. The idea of solution is the most important.

\javacode{Pro124}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 26 Remove Duplicates from Sorted Array
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 26 Remove Duplicates from Sorted Array}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a sorted array, remove the duplicates in place
     such that each element appear only once and return the new length.

    Do not allocate extra space for another array,
     you must do this in place with constant memory.

    For example,
    Given input array nums = [1,1,2],

    Your function should return length = 2,
     with the first two elements of nums being 1 and 2 respectively.
      It doesn't matter what you leave beyond the new length.

    https://leetcode.com/problems/remove-duplicates-from-sorted-array/

\end{lstlisting}

\textbf{Solution}

~~Keep a clean thought will help you solve the problem quickly.

\javacode{Pro26}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 80 Remove Duplicates from Sorted Array II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 80 Remove Duplicates from Sorted Array II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Follow up for "Remove Duplicates":
    What if duplicates are allowed at most twice?

    For example,
    Given sorted array nums = [1,1,1,2,2,3],

    Your function should return length = 5,
     with the first five elements of nums being 1, 1, 2, 2 and 3.
      It doesn't matter what you leave beyond the new length.

    https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/

\end{lstlisting}

\textbf{Solution}

~~Add a flag to check if we still allow a same element exists.

\javacode{Pro80}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 27 Remove Element
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 27 Remove Element}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an array and a value, remove all instances of that value
     in place and return the new length.

    The order of elements can be changed. It doesn't matter
     what you leave beyond the new length.

    https://leetcode.com/problems/remove-element/

\end{lstlisting}

\textbf{Solution}

~~So stupid to get 2 WA and a RE on such problem........

\javacode{Pro27}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 283 Move Zeroes
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 283 Move Zeroes}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an array nums, write a function to move all 0's to the end of it
     while maintaining the relative order of the non-zero elements.

    For example, given nums = [0, 1, 0, 3, 12],
     after calling your function, nums should be [1, 3, 12, 0, 0].

    Note:
    1. You must do this in-place without making a copy of the array.
    2. Minimize the total number of operations.

    https://leetcode.com/problems/move-zeroes/

\end{lstlisting}

\textbf{Solution}

~~An easy problem.

\javacode{Pro283}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 138 Copy List with Random Pointer
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 138 Copy List with Random Pointer}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    A linked list is given such that each node
     contains an additional random pointer
      which could point to any node in the list or null.

    Return a deep copy of the list.

    https://leetcode.com/problems/copy-list-with-random-pointer/

\end{lstlisting}

\textbf{Solution 1}

~~Solution 1 makes use of HashMap, mapping original node and copied node so that we can get the random node by querying from HashMap. Use a 2-pass solution to respectively deal with next pointer and random pointer.

\javacode{Pro138_1}{Solution 1}

\textbf{Solution 2}


~~Solution 2 changes the structure of the list. See figure

\includegraphics[width=0.75\columnwidth]{figures/138_copy_list_with_random_pointer}

~~ So that we can just use

~~~~$node.next.random = node.random.next$

\javacode{Pro138_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 207 Course Schedule
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 207 Course Schedule}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    There are a total of n courses you have to take, labeled from 0 to n - 1.

    Some courses may have prerequisites, for example to take course 0
     you have to first take course 1, which is expressed as a pair: [0,1]

    Given the total number of courses and a list of prerequisite pairs,
     is it possible for you to finish all courses?

    For example:

    2, [[1,0]]
    There are a total of 2 courses to take.
     To take course 1 you should have finished course 0. So it is possible.

    2, [[1,0],[0,1]]
    There are a total of 2 courses to take.
     To take course 1 you should have finished course 0,
      and to take course 0 you should also have finished course 1.
       So it is impossible.

    Note:
    The input prerequisites is a graph represented by a list of edges,
     not adjacency matrices.


    Hints:
    1. This problem is equivalent to finding if a cycle exists in a directed graph.
     If a cycle exists, no topological ordering exists
      and therefore it will be impossible to take all courses.
    2. Topological Sort via DFS - A great video tutorial (21 minutes)
     on Coursera explaining the basic concepts of Topological Sort.
    3. Topological sort could also be done via BFS.

    https://leetcode.com/problems/course-schedule/

\end{lstlisting}

\textbf{Solution 1}

~~A graph problem, use topological sort to solve. Equivalent to problems which identify whether there is a cycle in the graph. Use adjacency list to store edges for a easier calculation on indegrees. BFS sort.

\javacode{Pro207_1}{Solution 1}

\textbf{Solution 2}


~~Solution 2 uses DFS. We should explain the usage of array `visited'. For value 0, it means the node has not been visited at all; value 1 means that the adjacent nodes has already been visited; while value -1 means the node has been visited while the adjacencies are not totally visited.

\javacode{Pro207_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 210 Course Schedule II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 210 Course Schedule II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    There are a total of n courses you have to take, labeled from 0 to n - 1.

    Some courses may have prerequisites, for example to take course 0
     you have to first take course 1, which is expressed as a pair: [0,1]

    Given the total number of courses and a list of prerequisite pairs,
     return the ordering of courses you should take to finish all courses.

    There may be multiple correct orders, you just need to return one of them.
     If it is impossible to finish all courses, return an empty array.

    For example:

        2, [[1,0]]
    There are a total of 2 courses to take.
     To take course 1 you should have finished course 0.
      So the correct course order is [0,1]

        4, [[1,0],[2,0],[3,1],[3,2]]
    There are a total of 4 courses to take.
     To take course 3 you should have finished both courses 1 and 2.
      Both courses 1 and 2 should be taken after you finished course 0.
       So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].

    Note:
    The input prerequisites is a graph represented by a list of edges,
     not adjacency matrices.


    Hints:
    1. This problem is equivalent to finding if a cycle exists in a directed graph.
     If a cycle exists, no topological ordering exists
      and therefore it will be impossible to take all courses.
    2. Topological Sort via DFS - A great video tutorial (21 minutes)
     on Coursera explaining the basic concepts of Topological Sort.
    3. Topological sort could also be done via BFS.

    https://leetcode.com/problems/course-schedule-ii/

\end{lstlisting}

\textbf{Solution}

~~Similar to ``Course Schedule'', add a step to record each step, namely record the sequence polled from queue.

\javacode{Pro210}{Solution}



\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 1 Two Sum
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 1 Two Sum}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an array of integers, return indices of the two numbers
     such that they add up to a specific target.

    You may assume that each input would have exactly one solution.

    Example:
    Given nums = [2, 7, 11, 15], target = 9,

    Because nums[0] + nums[1] = 2 + 7 = 9,
    return [0, 1].

    https://leetcode.com/problems/two-sum/

\end{lstlisting}

\textbf{Solution}

~~ It's a very interesting series of problems.

~~ For all kSum conclusion , there is a good blog here

~~~~~~~~ \url{http://www.sigmainfy.com/blog/summary-of-ksum-problems.html}

~~As for this problem, there are mainly two ways, except for the Brute force method. First way is to use HashMap.

~~Solution utilizes two pointers to get the \textbf{unique} result also works. Sorting the list first is needed as a prerequisite. However, we need to keep the original index of number array. So here we just list the HashMap solution.

\javacode{Pro1}{Solution}



\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 167 Two Sum II - Input array is sorted
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 167 Two Sum II - Input array is sorted}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an array of integers that is already sorted in ascending order,
     find two numbers such that they add up to a specific target number.

    The function twoSum should return indices of the two numbers
     such that they add up to the target, where index1 must be less than index2.
      Please note that your returned answers (both index1 and index2) are not 0-based.

    You may assume that each input would have exactly one solution.

    Input: numbers={2, 7, 11, 15}, target=9
    Output: index1=1, index2=2

    https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/

\end{lstlisting}

\textbf{Solution - Two Pointers}

~~ Continue with solution discussion in preceding problem. Another way of solving the problem is to use 2-pointers. Note that the array should be sorted, which may lead to larger complexity among unsorted array. 2 pointers starts respectively from the beginning and ending of array, and when current sum is larger than target, move ending pointer forward, while on the contrast moving beginning pointer backward until they meet.

~~ Moreover, a trick for not getting TLE is to skip duplicate elements. Imagine an sample input of [0,0,...,0,4,9,...,9] with target=4. For pointers, we can feel free to use while loop to skip duplicates to prevent from costing too much time. If the target is 0, then it will be obtained by both idx1 and idx2, not influenced by a skipping process of a single idx pointer.

\javacode{Pro167_1}{Solution}


\textbf{Solution - Binary Search}

~~ Another way is to make use of binary search. Iterate elements in array(until the element is larger or equals to target / 2, think of it), and use binary search to find (target - cur) in array backwards. However the complexity may be a bit larger($O(n logn)$) than 2-pointers method.

\javacode{Pro167_2}{Solution}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 15 3Sum
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 15 3Sum}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an array S of n integers, are there elements a, b, c
     in S such that a + b + c = 0? Find all unique triplets
      in the array which gives the sum of zero.

    Note:
    Elements in a triplet (a,b,c) must be in non-descending order. (ie, a <= b <= c)
    The solution set must not contain duplicate triplets.
        For example, given array S = {-1 0 1 2 -1 -4},

        A solution set is:
        (-1, 0, 1)
        (-1, -1, 2)

    https://leetcode.com/problems/3sum/

\end{lstlisting}

\textbf{Solution}

~~ Finally we can use the 2 pointers solution.

~~ Note that in the problem, the description request us to prevent from producing duplicate triples, so we need a Set or just skip those duplicate elements to solve this problem.

\javacode{Pro15}{Solution}



\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 16 3Sum Closest
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 16 3Sum Closest}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an array S of n integers, find three integers in S
     such that the sum is closest to a given number, target.
      Return the sum of the three integers.
       You may assume that each input would have exactly one solution.

    For example, given array S = {-1 2 1 -4}, and target = 1.

    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).

    https://leetcode.com/problems/3sum-closest/

\end{lstlisting}

\textbf{Solution}

~~Personally, I think this is a bit easier than 3sum since I don't need to care about the duplicates.

\javacode{Pro16}{Solution}



\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 18 4Sum
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 18 4Sum}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an array S of n integers, are there elements a, b, c,
     and d in S such that a + b + c + d = target?
      Find all unique quadruplets in the array which gives the sum of target.

    Note:
    Elements in a quadruplet (a,b,c,d) must be in non-descending order.
     (ie, a  b  c  d)
    The solution set must not contain duplicate quadruplets.
        For example, given array S = {1 0 -1 0 -2 2}, and target = 0.

        A solution set is:
        (-1,  0, 0, 1)
        (-2, -1, 1, 2)
        (-2,  0, 0, 2)

    https://leetcode.com/problems/4sum/

\end{lstlisting}

\textbf{Solution}

~~Solving the kSum problem! Just one try!!!(Though not bug free...)

\javacode{Pro18}{Solution}



\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 55 Jump Game
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 55 Jump Game}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an array of non-negative integers, you are initially
     positioned at the first index of the array.

    Each element in the array represents your maximum jump length at that position.

    Determine if you are able to reach the last index.

    For example:
    A = [2,3,1,1,4], return true.

    A = [3,2,1,0,4], return false.

    https://leetcode.com/problems/jump-game/

\end{lstlisting}

\textbf{Solution}

~~A greedy or DP problem. The maximum steps we can go on is Math.max(curMax, nums[idx]), don't forget to reduce curMax by 1 simulating every step we proceed.

\javacode{Pro55}{Solution}

~~A more concise version. Do not need to deduct 1, only need to check if we can reach the first elements finally.

\javacode{Pro55_2}{Solution1.1}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 45 Jump Game II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 45 Jump Game II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an array of non-negative integers,
     you are initially positioned at the first index of the array.

    Each element in the array represents
     your maximum jump length at that position.

    Your goal is to reach the last index in the minimum number of jumps.

    For example:
    Given array A = [2,3,1,1,4]

    The minimum number of jumps to reach the last index is 2.
     (Jump 1 step from index 0 to 1, then 3 steps to the last index.)

    Note:
    You can assume that you can always reach the last index.

    https://leetcode.com/problems/jump-game-ii/

\end{lstlisting}

\textbf{Solution}

~~Still greedy, but needs some time to figure out the correctness....(Honestly, I don't think this is a complete greedy problem, since the solution is not that greedy. It's more like a DP problem.)

~~Let's say the range of the current jump is [curBegin, lastMax], curMax is the farthest point that all points in [curBegin, lastMax] can reach. Once the current point reaches lastMax, then trigger another jump, and set the new lastMax with curMax.

\javacode{Pro45}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 120 Triangle
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 120 Triangle}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a triangle, find the minimum path sum from top to bottom.
     Each step you may move to adjacent numbers on the row below.

    For example, given the following triangle
    [
         [2],
        [3,4],
       [6,5,7],
      [4,1,8,3]
    ]
    The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).

    Note:
    Bonus point if you are able to do this using only O(n) extra space,
     where n is the total number of rows in the triangle.

    https://leetcode.com/problems/triangle/

\end{lstlisting}

\textbf{Solution}

~~A dp problem, I think it is maybe in an easier level of dp problems.

~~ As for the bonus, manipulating on triangle variable itself is a fine idea. Just remember to mention the boundaries.

\javacode{Pro45}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 187 Repeated DNA Sequences
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 187 Repeated DNA Sequences}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T,
     for example: "ACGAATTCCG". When studying DNA,
      it is sometimes useful to identify repeated sequences within the DNA.

    Write a function to find all the 10-letter-long sequences (substrings)
     that occur more than once in a DNA molecule.

    For example,

    Given s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT",

    Return:
    ["AAAAACCCCC", "CCCCCAAAAA"].

    https://leetcode.com/problems/repeated-dna-sequences/

\end{lstlisting}

\textbf{Solution}

~~An interesting problem but not that easy. Using String Hashmap will get MLE. So we need to reduce the size of our data. That's when ``Bit Manipulation'' comes into sight. Since there are only 4 kinds of chars, we can mark them as `00',`01',`10',`11', so that we can use a 20-bit integer as the hash code of each 10-digit string, as it won't cost as much memory as String. See code in listing.

\javacode{Pro187}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 331 Verify Preorder Serialization of a Binary Tree
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 331 Verify Preorder Serialization of a Binary Tree}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    One way to serialize a binary tree is to use pre-order traversal.
     When we encounter a non-null node, we record the node's value.
      If it is a null node, we record using a sentinel value such as #.

         _9_
        /   \
       3     2
      / \   / \
     4   1  #  6
    / \ / \   / \
    # # # #   # #
    For example, the above binary tree can be serialized
     to the string "9,3,4,#,#,1,#,#,2,#,6,#,#", where # represents a null node.

    Given a string of comma separated values,
     verify whether it is
      a correct preorder traversal serialization of a binary tree.
      Find an algorithm without reconstructing the tree.

    Each comma separated value in the string must be
     either an integer or a character '#' representing null pointer.

    You may assume that the input format is always valid,
     for example it could never contain two consecutive commas such as "1,,3".

    Example 1:
        "9,3,4,#,#,1,#,#,2,#,6,#,#"
        Return true

    Example 2:
        "1,#"
        Return false

    Example 3:
        "9,#,#,1"
        Return false

    https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/

\end{lstlisting}

\textbf{Solution}

~~A stack problem may be more suitable for the orientation of this problem. The train of thought is somewhat like the Evaluation of Reverse Polish Expression.

~~ When scrape nodes from a complete subtree together, we may combine them into a `\#' to simplify the tree structure, finally we should only get a single `\#' in the stack.

~~ To be more specific, we first push every element we get into stack; if depth of current stack is larger or equal to 3 and the top 2 elements are both `\#' when the 3rd element is not(which will never happen, even if the original string contains 3 successive `\#', the first 2 will be combined into one single `\#'). We pop the 2 `\#'s out along with the 3rd non-`\#' element and push an extra `\#' instead.

~~ Repeat the whole process.

~~ Finally check if the remaining element in Stack is `\#'.

\javacode{Pro331}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 72 Edit Distance
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 72 Edit Distance}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given two words word1 and word2,
     find the minimum number of steps required to convert word1 to word2.
      (each operation is counted as 1 step.)

    You have the following 3 operations permitted on a word:

    a) Insert a character
    b) Delete a character
    c) Replace a character

    https://leetcode.com/problems/edit-distance/

\end{lstlisting}

\textbf{Solution}

~~ A representative DP problem.

~~ The train of thought is listed as below:

~~\includegraphics[width=0.75\columnwidth]{figures/72_edit_distance}

\javacode{Pro72}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 319 Bulb Switcher
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 319 Bulb Switcher}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    There are n bulbs that are initially off. You first turn on all the bulbs.
     Then, you turn off every second bulb.
      On the third round, you toggle every third bulb
       (turning on if it's off or turning off if it's on).
        For the ith round, you toggle every i bulb. For the nth round,
         you only toggle the last bulb. Find how many bulbs are on after n rounds.

    Example:

    Given n = 3.

    At first, the three bulbs are [off, off, off].
    After first round, the three bulbs are [on, on, on].
    After second round, the three bulbs are [on, off, on].
    After third round, the three bulbs are [on, off, off].

    So you should return 1, because there is only one bulb is on.

    https://leetcode.com/problems/bulb-switcher/

\end{lstlisting}

\textbf{Solution}

~~This is a very very very very interesting problem! Simulating the process is too time-consuming, so we need to find another way.

~~It can be easily discovered that when we switch the light for odd times, the state of light will change, while switching for even times won't. Now consider all numbers, for example, 12 = 1*12; 2*6; 3*4, will be switched 6 times, its state won't change; however, as for 25= 1*25; 5*5, it will change its state!!

~~ So the problem is exactly asking us to find how many square numbers are in the range of 1~n.

\javacode{Pro319}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 42 Trapping Rain Water
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 42 Trapping Rain Water}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given n non-negative integers representing an elevation map
     where the width of each bar is 1,
      compute how much water it is able to trap after raining.

    For example,
    Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.


    The above elevation map is represented by array
     [0,1,0,2,1,0,1,3,2,1,2,1]. In this case,
      6 units of rain water (blue section) are being trapped.

    https://leetcode.com/problems/trapping-rain-water/

\end{lstlisting}

\includegraphics[width=0.8\columnwidth]{figures/42_trapping_rain_water}

\textbf{Solution}

~~Use 2 pointers is the key to this problem. One from left, one from right, find the lower value for the candidate and find `traps' whose depth is lower than current minimum(between left and right) and add the depth to amount of total water, until finding a new peak.

\javacode{Pro42}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 11 Container With Most Water
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 11 Container With Most Water}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given n non-negative integers a1, a2, ..., an,
     where each represents a point at coordinate (i, ai).
      n vertical lines are drawn such that the two endpoints
        of line i is at (i, ai) and (i, 0). Find two lines,
         which together with x-axis forms a container,
          such that the container contains the most water.

    https://leetcode.com/problems/container-with-most-water/

\end{lstlisting}

\textbf{Solution}

~~ Somewhat like 2Sum, use 2 pointers to achieve this. The greedy algorithm needs proving.

\javacode{Pro11}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 51 N-Queens
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 51 N-Queens}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    The n-queens puzzle is the problem of placing n queens
     on an n*n chessboard such that no two queens attack each other.



    Given an integer n, return all distinct solutions to the n-queens puzzle.

    Each solution contains a distinct board configuration of
     the n-queens' placement,
      where 'Q' and '.' both indicate a queen and an empty space respectively.

    For example,
    There exist two distinct solutions to the 4-queens puzzle:

    [
     [".Q..",  // Solution 1
      "...Q",
      "Q...",
      "..Q."],

     ["..Q.",  // Solution 2
      "Q...",
      "...Q",
      ".Q.."]
    ]

    https://leetcode.com/problems/n-queens/

\end{lstlisting}

\includegraphics[width=0.4\columnwidth]{figures/51_n_queens}

\textbf{Solution}

~~``N-queens'' is a representative series of problem in backtracking problems.

~~ However the train of thought is not that difficult, instead it's somewhat straightforward.

~~ In the next problem `N-queen-ii`, another solution with $O(n) space$ will be displayed.

\javacode{Pro51}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 52 N-Queens II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 52 N-Queens II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Follow up for N-Queens problem.

    Now, instead outputting board configurations,
     return the total number of distinct solutions.

    https://leetcode.com/problems/n-queens-ii/

\end{lstlisting}

\textbf{Solution}

~~This is not much harder than N-Queen, the ideas are the same. But this time a $O(n) space$ solution will be displayed. It doesn't use a two-dimensional array to keep the condition of the puzzle, instead use an a[i] array where a[i] representing the index of $i^{th}$ row.

~~So how to judge whether the position is available? The array is of 1-dimension, so there won't be conflict in rows, checking whether columns conflict are also not difficult, what about diagonalization? Observation gives us the answer that when two point fit the attribute that x1 + y1 = x2 + y2 OR x1 - y1 = x2 - y2, eg (1,2) \& (2,1) OR (1,2) \& (2,3), they are on the same diagonal line.

\javacode{Pro52}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 217 Contains Duplicate
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 217 Contains Duplicate}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given an array of integers, find if the array contains any duplicates.
     Your function should return true if any value appears
      at least twice in the array,
       and it should return false if every element is distinct.

    https://leetcode.com/problems/contains-duplicate/

\end{lstlisting}

\textbf{Solution}

~~ A HashSet is enough for the problem series I and II.

\javacode{Pro217}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 219 Contains Duplicate II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 219 Contains Duplicate II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given an array of integers and an integer k,
     find out whether there are two distinct indices i and j
      in the array such that nums[i] = nums[j]
       and the difference between i and j is at most k.

    https://leetcode.com/problems/contains-duplicate-ii/

\end{lstlisting}

\textbf{Solution}

~~ Either use a HashMap to record the latest index of element or use a k-length slide window is fine. Here I'm using a k-length slide window(made of HashSet) to solve the problem.

\javacode{Pro219}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 220 Contains Duplicate III
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 220 Contains Duplicate III}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given an array of integers,
     find out whether there are two distinct indices
      i and j in the array such that the difference
       between nums[i] and nums[j] is at most t and
        the difference between i and j is at most k.

    https://leetcode.com/problems/contains-duplicate-iii/

\end{lstlisting}

\textbf{Solution}

~~ Use a existence data structure TreeSet, which has both the attribute of Set and Binary Search Tree, a perfect match of this problem.

\javacode{Pro220}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 75 Sort Colors
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 75 Sort Colors}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given an array with n objects colored red, white or blue,
     sort them so that objects of the same color are adjacent,
      with the colors in the order red, white and blue.

    Here, we will use the integers 0, 1, and 2
     to represent the color red, white, and blue respectively.

    Note:
    You are not suppose to use the library's sort function
     for this problem.


    Follow up:
    A rather straight forward solution is a two-pass algorithm
     using counting sort.
    First, iterate the array counting number of 0's, 1's, and 2's,
     then overwrite array with total number of 0's, then 1's and followed by 2's.

    Could you come up with an one-pass algorithm using only constant space?

    https://leetcode.com/problems/sort-colors/

\end{lstlisting}

\textbf{Solution}

~~ Use two pointers to mark where the index of 0 and 2 are(In fact, there are 3 pointers, the main idx pointer marks where 1s are.)

~~ In LintCode, there is a Sort Colors II, for k colors. The key insight is like bucket sorting.

\javacode{Pro75}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 39 Combination Sum
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 39 Combination Sum}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a set of candidate numbers (C) and a target number (T),
     find all unique combinations in C where the candidate numbers sums to T.

    The same repeated number may be chosen from C unlimited number of times.

    Note:
    All numbers (including target) will be positive integers.
    Elements in a combination (a1, a2, ... , ak) must be in non-descending order.
     (ie, a1 <= a2 <= ... <= ak).
    The solution set must not contain duplicate combinations.
    For example, given candidate set 2,3,6,7 and target 7,
    A solution set is:
    [7]
    [2, 2, 3]

    https://leetcode.com/problems/combination-sum/

\end{lstlisting}

\textbf{Solution}

~~ A dfs problem. Remember to sort the array first since $Elements\ in\ a\ combination\ (a1, a2, ... , ak)\ must\ be\ in\ non-descending\ order.$

\javacode{Pro39}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 40 Combination Sum II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 40 Combination Sum II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a collection of candidate numbers (C) and a target number (T),
     find all unique combinations in C where the candidate numbers sums to T.

    Each number in C may only be used once in the combination.

    Note:
    All numbers (including target) will be positive integers.
    Elements in a combination (a1, a2, ... , ak)
     must be in non-descending order. (ie, a1 <= a2 <= ... <= ak).
    The solution set must not contain duplicate combinations.
    For example, given candidate set 10,1,2,7,6,1,5 and target 8,
    A solution set is:
    [1, 7]
    [1, 2, 5]
    [2, 6]
    [1, 1, 6]

    https://leetcode.com/problems/combination-sum-ii/

\end{lstlisting}

\textbf{Solution}

~~ More difficult than ``Combination Sum'', mainly on how to deal with duplicates. Except for set the startIdx to lastIdx + 1 to avoid using the same elements, we should also use a while loop to avoid using elements with the same value after we have already combined them.

\javacode{Pro40}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 216 Combination Sum III
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 216 Combination Sum III}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Find all possible combinations of k numbers that add up to a number n,
     given that only numbers from 1 to 9 can be used and
      each combination should be a unique set of numbers.

    Ensure that numbers within the set are sorted in ascending order.


    Example 1:

    Input: k = 3, n = 7

    Output:

    [[1,2,4]]

    Example 2:

    Input: k = 3, n = 9

    Output:

    [[1,2,6], [1,3,5], [2,3,4]]

    https://leetcode.com/problems/combination-sum-iii/

\end{lstlisting}

\textbf{Solution}

~~ Don't know if it is my illusion, I think this Problem is a bit easier than ``Combination Sum II'' since it doesn't need to be processed to avoid duplicates.

\javacode{Pro216}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 377 Combination Sum IV
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 377 Combination Sum IV}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an integer array with all positive numbers and no duplicates,
     find the number of possible combinations that add up to a positive integer target.
    Example:
    nums = [1, 2, 3]
    target = 4

    The possible combination ways are:
    (1, 1, 1, 1)
    (1, 1, 2)
    (1, 2, 1)
    (1, 3)
    (2, 1, 1)
    (2, 2)
    (3, 1)

    Note that different sequences are counted as different combinations.

    Therefore the output is 7.

    Follow up:
    What if negative numbers are allowed in the given array?
    How does it change the problem?
    What limitation we need to add to the question to allow negative numbers?

    https://leetcode.com/problems/combination-sum-iv/

\end{lstlisting}

\textbf{Solution - TLE}

~~ Raw backtracking will get TLE, like this.

\javacode{Pro377_1_1}{Solution 1.1 TLE backtracking}

\textbf{Solution - Pruning with memoization}

~~ We may use a Hashmap to store results for pruning.

\javacode{Pro377_1_2}{Solution 1.2 Memoization backtracking}

\textbf{Solution - DP}

~~ The thought is alike memoization, use dp[i] += dp[i - num]

\javacode{Pro377_2}{Solution 2 DP}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 48 Rotate Image
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 48 Rotate Image}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    You are given an n * n 2D matrix representing an image.

    Rotate the image by 90 degrees (clockwise).

    Follow up:
    Could you do this in-place?

    https://leetcode.com/problems/rotate-image/

\end{lstlisting}

\textbf{Solution}

~~Finding the rule of swapping is the key to solving the problem. (Honestly, my solution is not exactly in-place since I used a boolean array to check if the number in grid has been changed. I'll list the proper code downward my solution.

~~ However, the world has taught us not to under-estimate every problem, there is also another interesting way of solving the problem: when we regard the matrix as a paper, we fold the paper up and down, then fold it along the diagonal, we will realize this is exactly the result we want!

\javacode{Pro48}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 53 Maximum Subarray
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 53 Maximum Subarray}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Find the contiguous subarray within an array
     (containing at least one number) which has the largest sum.

    For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
    the contiguous subarray [4,-1,2,1] has the largest sum = 6.


    More practice:
    If you have figured out the O(n) solution,
     try coding another solution using the divide and conquer approach,
      which is more subtle.

    https://leetcode.com/problems/maximum-subarray/

\end{lstlisting}

\textbf{Solution}

~~ This is a conventional DP problem, it's worth us carefully thinking about it.

~~ What's the first solution comes into mind at first sight? Enumeration, of course, the Brute force method. However, when we talk about its complexity, we may need $O(n)$ to iterate both i and j, along with an extra $O(n)$ effort to sum up a[i...j], $O(N^3)$ in total.

\javacode{Pro53_guide_1}{Guide 1}

~~ How to optimize? Can we calculate the sum during the process of enumeration? The sum is actually formerSum + a[idx-1].

\javacode{Pro53_guide_2}{Guide 2}

~~ Divide and Conquer can even promote our solution further more. We may find a middle point, and the maximum subarray sum lies either on left, right, or go through the middle element(since we are finding consecutive sequence). Then the steps of algorithm is  to separate subarray according to a middle element and calculate optimal sum sum1 and sum2 start from middle element(With the time complexity $2*T(n/2) + O(n) = O(n logn)$);

~~ Finally we can use DP to solve it. Let dp[i] be the maximum we can get until idx i, so dp[i] = max{dp[i - 1] + nums[i], nums[i]}.


\javacode{Pro53_1}{Solution}

\textbf{Solution Follow-up}

~~ The follow up need us to do it in a divide and conquer way which is mentioned above, as listing, the code is copied from Internet, respectively calculating sums [startIdx, currentIdx], [currentIdx + 1, endIdx] and [startIdx, endIdx], use a binary search method to decide the value of currentIdx(so the runtime complexity is $O(n logn)$).

\javacode{Pro53_2}{Solution Follow-up}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 152 Maximum Product Subarray
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 152 Maximum Product Subarray}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Find the contiguous subarray within an array
     (containing at least one number) which has the largest product.

    For example, given the array [2,3,-2,4],
    the contiguous subarray [2,3] has the largest product = 6.

    https://leetcode.com/problems/maximum-product-subarray/

\end{lstlisting}

\textbf{Solution}

~~The solution of this problem is a bit like ``Maximum Subarray'', except for the fact that we use an extra array to store the minimum product until idx since minimum value may also produce maximum value since negatives multiply negatives equal positives.

\javacode{Pro152}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 238 Product of Array Except Self
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 238 Product of Array Except Self}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an array of n integers where n > 1, nums,
     return an array output such that output[i]
      is equal to the product of all the elements of nums except nums[i].

    Solve it without division and in O(n).

    For example, given [1,2,3,4], return [24,12,8,6].

    Follow up:
    Could you solve it with constant space complexity?
     (Note: The output array does not count as extra space
      for the purpose of space complexity analysis.)

    https://leetcode.com/problems/product-of-array-except-self/

\end{lstlisting}

\textbf{Solution}

~~Solution using $O(n) space$ is trivial, so I just put the $O(1) space$(except for the result array) solution here. It's like multiplying a matrix, from start of array to the end, result[i] = result[i - 1] * a[i - 1](avoiding multiplying a[i]), then backward, result[i] = result[i] * a[i + 1].

\javacode{Pro238}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 133 Clone Graph
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 133 Clone Graph}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Clone an undirected graph.
     Each node in the graph contains a label and a list of its neighbors.


    OJ's undirected graph serialization:
    Nodes are labeled uniquely.

    We use # as a separator for each node, and ,
     as a separator for node label and each neighbor of the node.
    As an example, consider the serialized graph {0,1,2#1,2#2,2}.

    The graph has a total of three nodes,
     and therefore contains three parts as separated by #.

    First node is labeled as 0. Connect node 0 to both nodes 1 and 2.
    Second node is labeled as 1. Connect node 1 to node 2.
    Third node is labeled as 2. Connect node 2 to node 2 (itself),
     thus forming a self-cycle.
    Visually, the graph looks like the following:

           1
          / \
         /   \
        0 --- 2
             / \
             \_/

    https://leetcode.com/problems/clone-graph/

\end{lstlisting}

\textbf{Solution}

~~Using a HashMap to map original node and cloned node(just like what we did in `Copy List With Random Pointer`), then use BFS or DFS to clone the whole graph. For practise, I list DFS solution here.

\javacode{Pro133}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 153 Find Minimum in Rotated Sorted Array
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 153 Find Minimum in Rotated Sorted Array}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Suppose a sorted array is rotated at some pivot unknown to you beforehand.

    (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

    Find the minimum element.

    You may assume no duplicate exists in the array.

    https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/

\end{lstlisting}

\textbf{Solution}

~~ A binary search problem. Of course we can do it in $O(n) runtime$ by iterating the list linearly, but binary search is of course better for its $O(log n) runtime$.

\javacode{Pro153}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 154 Find Minimum in Rotated Sorted Array II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 154 Find Minimum in Rotated Sorted Array II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Follow up for "Find Minimum in Rotated Sorted Array":
    What if duplicates are allowed?

    Would this affect the run-time complexity? How and why?
    Suppose a sorted array is rotated at some pivot unknown to you beforehand.

    (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

    Find the minimum element.

    The array may contain duplicates.

    https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/

\end{lstlisting}

\textbf{Solution}

~~This one is following previous problem ``Find Minimum in Rotated Sorted Array'', and though there are only several lines of code that are different, the problem is much harder than previous one. Take care of the condition when there are plenty of duplicates, for example, when the list is 10,1,10,10,10, this is when a[low] $<$ a[high], which is not we want when using binary search(Think of why?).

\javacode{Pro154}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 33 Search in Rotated Sorted Array
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 33 Search in Rotated Sorted Array}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Suppose a sorted array is rotated at some pivot unknown to you beforehand.

    (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

    You are given a target value to search.
     If found in the array return its index, otherwise return -1.

    You may assume no duplicate exists in the array.

    https://leetcode.com/problems/search-in-rotated-sorted-array/

\end{lstlisting}

\textbf{Solution}

~~A complicated binary search problem, need to check if the target is in monotone interval(always increasing) or on the other side. Don't forget to check if the element matches start or end pointer of list.

\javacode{Pro33}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 81 Search in Rotated Sorted Array II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 81 Search in Rotated Sorted Array II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Follow up for "Search in Rotated Sorted Array":
    What if duplicates are allowed?

    Would this affect the run-time complexity? How and why?

    Write a function to determine if a given target is in the array.

    https://leetcode.com/problems/search-in-rotated-sorted-array-ii/

\end{lstlisting}

\textbf{Solution}

~~With the experience of last problem ``Search in Rotated Sorted Array'', solving this problem is not that difficult. Still, when we find nums[start] == nums[mid] == nums[end], we just increase start by 1 since we are not sure where our target is([10,1,10,10,10] \& [10,10,10,1,10]).

~~ What's more, in this solution I slightly simplify my code in previous problem.

\javacode{Pro81}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 76 Minimum Window Substring
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 76 Minimum Window Substring}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a string S and a string T,
     find the minimum window in S which
      will contain all the characters in T in complexity O(n).

    For example,
    S = "ADOBECODEBANC"
    T = "ABC"
    Minimum window is "BANC".

    Note:
    If there is no such window in S
     that covers all characters in T, return the empty string "".

    If there are multiple such windows,
     you are guaranteed that there will always be
      only one unique minimum window in S.

    https://leetcode.com/problems/minimum-window-substring/

\end{lstlisting}

\textbf{Solution}

~~A troublesome problem. Use two pointers to maintain current window, containing all characters we need in t string. And under the guaranteeing circumstances that our window contains all digits we want, we may shrink the window by moving the left pointer to right; when the window is no longer adequate, we move the right pointer forward to meet the requirement.

\javacode{Pro76}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 78 Subsets
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 78 Subsets}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a set of distinct integers, nums,
     return all possible subsets.

    Note:
    Elements in a subset must be in non-descending order.
    The solution set must not contain duplicate subsets.
    For example,
    If nums = [1,2,3], a solution is:

    [
      [3],
      [1],
      [2],
      [1,2,3],
      [1,3],
      [2,3],
      [1,2],
      []
    ]

    https://leetcode.com/problems/subsets/

\end{lstlisting}

\textbf{Solution 1}

~~Take [1,2,3] for example.

~~ Initially, the result is empty, namely [[]].

~~ Then, we add 1 to result, combine the result with former ones, that is [[],\textbf{[1]}]

~~ Next, we add 2 to every list in result, also combine the new and old list together, [[],[1],\textbf{[2],[1,2]}]

~~ Finally, it's 3's turn, we get [[],[1],[2],[1,2],\textbf{[3],[1,3],[2,3],[1,2,3]}] as our final result.

\javacode{Pro78_1}{Solution 1}

\textbf{Solution 2}

~~ The second solution is a DFS method. Interesting since it utilized 2 same function call to simulate picking or not picking element at curIdx.

\javacode{Pro78_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 90 Subsets II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 90 Subsets II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a collection of integers that might contain duplicates,
     nums, return all possible subsets.

    Note:
    Elements in a subset must be in non-descending order.
    The solution set must not contain duplicate subsets.
    For example,
    If nums = [1,2,2], a solution is:

    [
      [2],
      [1],
      [1,2,2],
      [2,2],
      [1,2],
      []
    ]

    https://leetcode.com/problems/subsets-ii/

\end{lstlisting}

\textbf{Solution 1}

~~The train of thought is similar to Solution 1 in Problem ``Subsets I''(Subsets II can also be solved using Solution 2). The key is on how to deal with the duplicates. Mention that when current element equals to last element, eg, 2 \& 2 in [1,2,2], the new list generated are only from what has just been generated in last round.

\javacode{Pro90_1}{Solution 1}


\textbf{Solution 2}

~~The backtracking method. Dealing with duplicates are also the key insight. The train of thought is somewhat like solution in ``Combination Sum II''.

\javacode{Pro90_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 303 Range Sum Query - Immutable
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 303 Range Sum Query - Immutable}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an integer array nums,
     find the sum of the elements between indices i and j (i <= j), inclusive.

    Example:
    Given nums = [-2, 0, 3, -5, 2, -1]

    sumRange(0, 2) -> 1
    sumRange(2, 5) -> -1
    sumRange(0, 5) -> -3
    Note:
    You may assume that the array does not change.
    There are many calls to sumRange function.

    https://leetcode.com/problems/range-sum-query-immutable/

\end{lstlisting}

\textbf{Solution}

~~Not a bad problem. Since the sumRange function may be called often, adding them every time we call the function sounds a bad idea. Use a sum array to store the sums for convenience. Mention the boundaries.

\javacode{Pro303}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 307 Range Sum Query - Mutable
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 307 Range Sum Query - Mutable}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an integer array nums, find the sum
     of the elements between indices i and j (i <= j), inclusive.

    The update(i, val) function modifies nums by
     updating the element at index i to val.
    Example:
    Given nums = [1, 3, 5]

    sumRange(0, 2) -> 9
    update(1, 2)
    sumRange(0, 2) -> 8
    Note:
    The array is only modifiable by the update function.
    You may assume the number of calls to update and
     sumRange function is distributed evenly.

    https://leetcode.com/problems/range-sum-query-mutable/

\end{lstlisting}

\textbf{Solution}

~~ Using solution in former problem ``Range Sum Query - Immutable'' will get TLE, so try some other solutions.

~~Make use of a freaking awesome data structure of niubility! Binary Index Tree(or Fenwick Tree)!

~~ For more reference on index trees, see

~~\url{http://www.doc88.com/p-9475113829694.html}

~~\url{http://blog.csdn.net/int64ago/article/details/7429868}

~~\url{https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/}

~~ Something need to be considered or mistakes I have made:

~~~~nums[0] is not in BIT since lowbit(0) == 0 will cause a infinite loop, so nums[0] is resolved seperately.

~~~~I forgot to update nums array but just update BIT, which brings me confusion on what is wrong with my solution.

~~~~Be aware of the boundaries.

\javacode{Pro307}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 304 Range Sum Query 2D - Immutable
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 304 Range Sum Query 2D - Immutable}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a 2D matrix `matrix', find the sum of the elements
     inside the rectangle defined by its upper left corner
      (row1, col1) and lower right corner (row2, col2).

    Range Sum Query 2D
    The above rectangle (with the red border) is defined by
     (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.

    Example:
    Given matrix = [
      [3, 0, 1, 4, 2],
      [5, 6, 3, 2, 1],
      [1, 2, 0, 1, 5],
      [4, 1, 0, 1, 7],
      [1, 0, 3, 0, 5]
    ]

    sumRegion(2, 1, 4, 3) -> 8
    sumRegion(1, 1, 2, 2) -> 11
    sumRegion(1, 2, 2, 4) -> 12
    Note:
    You may assume that the matrix does not change.
    There are many calls to sumRegion function.
    You may assume that row1  row2 and col1  col2.

    https://leetcode.com/problems/range-sum-query-2d-immutable/

\end{lstlisting}

\textbf{Solution}

~~An easy dp problem but costs me half an hour and 10 WA or RE since I made a mistake on dealing with the array index. Reserve an buffer is a good choice.

\javacode{Pro304}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 198 House Robber
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 198 House Robber}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    You are a professional robber planning to rob houses along a street.
     Each house has a certain amount of money stashed,
      the only constraint stopping you from robbing each of them
       is that adjacent houses have security system connected and
        it will automatically contact the police if two adjacent houses
         were broken into on the same night.

    Given a list of non-negative integers representing
     the amount of money of each house,
      determine the maximum amount of money you can rob tonight
       without alerting the police.

    https://leetcode.com/problems/house-robber/

\end{lstlisting}

\textbf{Solution}

~~A bit like finding the maximum increasing sequence, the dp function is exactly max{a[i-1], a[i-2] + nums[i]}, but take care of the initialization part(I made a mistake here), a[0] = nums[0], a[1] = Math.max(nums[0],nums[1]);

\javacode{Pro198}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 213 House Robber II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 213 House Robber II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Note: This is an extension of House Robber.

    After robbing those houses on that street,
     the thief has found himself a new place for his thievery
      so that he will not get too much attention.
       This time, all houses at this place are arranged in a circle.
        That means the first house is the neighbor of the last one.
         Meanwhile, the security system for these houses remain
          the same as for those in the previous street.

    Given a list of non-negative integers representing
     the amount of money of each house,
      determine the maximum amount of money you can rob tonight
       without alerting the police.

    https://leetcode.com/problems/house-robber-ii/

\end{lstlisting}

\textbf{Solution}

~~A cyclic DP problem, we can separate the problem into 2 linear DP problems by assuming whether rob the first house(so that the last can't be robbed) or don't rob it.

\javacode{Pro213}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 337 House Robber III
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 337 House Robber III}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    The thief has found himself a new place for his thievery again.
     There is only one entrance to this area, called the "root."
      Besides the root, each house has one and only one parent house.
       After a tour, the smart thief realized that
        "all houses in this place forms a binary tree".
         It will automatically contact the police if
          two directly-linked houses were broken into on the same night.

    Determine the maximum amount of money the thief can
     rob tonight without alerting the police.

    Example 1:
         3
        / \
       2   3
        \   \
         3   1
    Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.
    Example 2:
         3
        / \
       4   5
      / \   \
     1   3   1
    Maximum amount of money the thief can rob = 4 + 5 = 9.

    https://leetcode.com/problems/house-robber-iii/

\end{lstlisting}

\textbf{Solution}

~~ When the thief see a house, he has 2 choices, rob it or don't rob it. When he decides to rob it, things are simple, he cannot rob the 2 children houses; but not robbing is a bit complicated, he need to re-decide when he meets the 2 children houses whether he should rob it.

\javacode{Pro337}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 10 Regular Expression Matching
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 10 Regular Expression Matching}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Implement regular expression matching with support for '.' and '*'.

    '.' Matches any single character.
    '*' Matches zero or more of the preceding element.

    The matching should cover the entire input string (not partial).

    The function prototype should be:
    bool isMatch(const char *s, const char *p)

    Some examples:
    isMatch("aa","a") -> false
    isMatch("aa","aa") -> true
    isMatch("aaa","aa") -> false
    isMatch("aa", "a*") -> true
    isMatch("aa", ".*") -> true
    isMatch("ab", ".*") -> true
    isMatch("aab", "c*a*b") -> true

    https://leetcode.com/problems/regular-expression-matching/

\end{lstlisting}

\textbf{Solution}

~~A very complicated backtracking problem, takes me 1 and a half hour to finish it(and even in an IDE!!!)........

~~Both this problem and next problem needs to be supplemented with missing DP or recursion solutions.

~~ See \url{http://www.xuebuyuan.com/1936978.html}, good illustration.

\javacode{Pro10_1_1}{Solution 1.1}

~~Append a rather simple code...

\javacode{Pro10_1_2}{Solution 1.2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 44 Wildcard Matching
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 44 Wildcard Matching}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Implement wildcard pattern matching with support for '?' and '*'.

    '?' Matches any single character.
    '*' Matches any sequence of characters (including the empty sequence).

    The matching should cover the entire input string (not partial).

    The function prototype should be:
    bool isMatch(const char *s, const char *p)

    Some examples:
    isMatch("aa","a") -> false
    isMatch("aa","aa") -> true
    isMatch("aaa","aa") -> false
    isMatch("aa", "*") -> true
    isMatch("aa", "a*") -> true
    isMatch("ab", "?*") -> true
    isMatch("aab", "c*a*b")  false

    https://leetcode.com/problems/wildcard-matching/

\end{lstlisting}

\textbf{Solution}

~~Displaying the DP solution.

\javacode{Pro44}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 73 Set Matrix Zeroes
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 73 Set Matrix Zeroes}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a m x n matrix, if an element is 0,
     set its entire row and column to 0. Do it in place.

    Follow up:
    Did you use extra space?
    A straight forward solution using O(mn) space is probably a bad idea.
    A simple improvement uses O(m + n) space, but still not the best solution.
    Could you devise a constant space solution?

    https://leetcode.com/problems/set-matrix-zeroes/

\end{lstlisting}

\textbf{Solution}

~~Solution using $O(mn) space$ is too trivial. First show the result using $O(mn) space$, then the $O(1) space$ solution.

\javacode{Pro73_1_1}{Solution 1.1}

~~ The $O(1) space$ solution. Use the 1st(index 0) row and 1st column to mark 0 when there is a grid valued 0 with the same rowIdx or colIdx. Attention! We should deal with the 1st row and column separately, or it will be influenced and make all grids 0!

\javacode{Pro73_1_2}{Solution 1.2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 329 Longest Increasing Path in a Matrix
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 329 Longest Increasing Path in a Matrix}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an integer matrix,
     find the length of the longest increasing path.

    From each cell, you can either move to four directions:
     left, right, up or down.
      You may NOT move diagonally or move outside of the boundary
       (i.e. wrap-around is not allowed).

    Example 1:

    nums = [
      [9,9,4],
      [6,6,8],
      [2,1,1]
    ]
    Return 4
    The longest increasing path is [1, 2, 6, 9].

    Example 2:

    nums = [
      [3,4,5],
      [3,2,6],
      [2,2,1]
    ]
    Return 4
    The longest increasing path is [3, 4, 5, 6].
     Moving diagonally is not allowed.

    https://leetcode.com/problems/longest-increasing-path-in-a-matrix/

\end{lstlisting}

\textbf{Solution}

~~A DP(?), DFS and memoization problem. Not that difficult.

\javacode{Pro329}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 93 Restore IP Addresses
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 93 Restore IP Addresses}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a string containing only digits,
     restore it by returning all possible valid IP address combinations.

    For example:
    Given "25525511135",

    return ["255.255.11.135", "255.255.111.35"]. (Order does not matter)

    https://leetcode.com/problems/restore-ip-addresses/

\end{lstlisting}

\textbf{Solution}

~~Honestly, this is not such a difficult question, but there are so many edge cases in this problem, which make us busy debugging when we meet a new edge case.

~~ Take care of those:

~~~~ (1) numbers starts with `0' except for 0 itself;

~~~~ (2) length out of bounds

~~~~ (3) more than 4 numbers generated

~~~~ (4) number more than 255

~~~~ (5) number with the length of more than 3

\javacode{Pro93}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 131 Palindrome Partitioning
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 131 Palindrome Partitioning}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a string s, partition s such that
     every substring of the partition is a palindrome.

    Return all possible palindrome partitioning of s.

    For example, given s = "aab",
    Return

      [
        ["aa","b"],
        ["a","a","b"]
      ]

    https://leetcode.com/problems/palindrome-partitioning/

\end{lstlisting}

\textbf{Solution}

~~A not so difficult backtracking problem, add string to list if the string is palindrome.

\javacode{Pro131}{Solution}

\end{homeworkProblem}
\newpage


%----------------------------------------------------------------------------------------
%	PROBLEM 132 Palindrome Partitioning II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 132 Palindrome Partitioning II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a string s, partition s such that every substring
     of the partition is a palindrome.

    Return the minimum cuts needed for a palindrome partitioning of s.

    For example, given s = "aab",
    Return 1 since the palindrome partitioning ["aa","b"]
     could be produced using 1 cut.

    https://leetcode.com/problems/palindrome-partitioning-ii/

\end{lstlisting}

\textbf{Solution}

~~Solution from previous Problem ``Palindrome Partitioning'' will get TLE with long sequence with so many palindromes within it.(Even when I changed the train of thought to find the longest palindrome first and do the pruning when result list size is larger than min)

~~So DP will be the alternative.

\javacode{Pro132}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 38 Count and Say
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 38 Count and Say}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    The count-and-say sequence is the sequence of integers
     beginning as follows:
    1, 11, 21, 1211, 111221, ...

    1 is read off as "one 1" or 11.
    11 is read off as "two 1s" or 21.
    21 is read off as "one 2, then one 1" or 1211.
    Given an integer n, generate the nth sequence.

    Note: The sequence of integers will be represented as a string.

    https://leetcode.com/problems/count-and-say/

\end{lstlisting}

\textbf{Solution}

~~Attention for the easy problems, not as easy as I thought.

\javacode{Pro38}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 324 Wiggle Sort II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 324 Wiggle Sort II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an unsorted array nums,
     reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....

    Example:
    (1) Given nums = [1, 5, 1, 1, 6, 4],
         one possible answer is [1, 4, 1, 5, 1, 6].
    (2) Given nums = [1, 3, 2, 2, 3, 1],
         one possible answer is [2, 3, 1, 3, 1, 2].

    Note:
    You may assume all input has valid answer.

    Follow Up:
    Can you do it in O(n) time and/or in-place with O(1) extra space?

    https://leetcode.com/problems/wiggle-sort-ii/

\end{lstlisting}

\textbf{Solution}

~~Using wiggleIndex to re-index the array is the key to solving this. the formula is $(2*i+1) \% (n|1)$. A[0,1,2,3,4,4] will be mapped to a[1,3,5,0,2,4], respectively.

\javacode{Pro324}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 289 Game of Life
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 289 Game of Life}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    According to the Wikipedia's article:
     "The Game of Life, also known simply as Life,
      is a cellular automaton devised by the British mathematician
       John Horton Conway in 1970."

    Given a board with m by n cells,
     each cell has an initial state live (1) or dead (0).
      Each cell interacts with its eight neighbors
       (horizontal, vertical, diagonal) using the following four rules
        (taken from the above Wikipedia article):

    Any live cell with fewer than two live neighbors dies,
     as if caused by under-population.
    Any live cell with two or three live neighbors lives on to the next generation.
    Any live cell with more than three live neighbors dies,
     as if by over-population..
    Any dead cell with exactly three live neighbors becomes a live cell,
     as if by reproduction.
    Write a function to compute the next state
     (after one update) of the board given its current state.

    Follow up:
    Could you solve it in-place?
     Remember that the board needs to be updated at the same time:
      You cannot update some cells first and then use
       their updated values to update other cells.
    In this question, we represent the board using a 2D array.
     In principle, the board is infinite,
      which would cause problems when the active area
       encroaches the border of the array.
        How would you address these problems?

    https://leetcode.com/problems/game-of-life/

\end{lstlisting}

\textbf{Solution}

~~Bit manipulation is the first thought which comes into my mind, use 1st digit as next state and 2nd digit for current state.

\javacode{Pro289}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 165 Compare Version Numbers
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 165 Compare Version Numbers}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Compare two version numbers version1 and version2.
    If version1 > version2 return 1, if version1 < version2 return -1,
     otherwise return 0.

    You may assume that the version strings are
     non-empty and contain only digits and the . character.
    The . character does not represent
     a decimal point and is used to separate number sequences.
    For instance, 2.5 is not "two and a half" or
     "half way to version three",
      it is the fifth second-level revision of the second first-level revision.

    Here is an example of version numbers ordering:

    0.1 < 1.1 < 1.2 < 13.37

    https://leetcode.com/problems/compare-version-numbers/

\end{lstlisting}

\textbf{Solution}

~~Though simple, do not miss the edge cases when `1.0.0' equals `1'

\javacode{Pro165}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 58 Length of Last Word
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 58 Length of Last Word}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a string s consists of upper/lower-case alphabets
     and empty space characters ' ',
      return the length of last word in the string.

    If the last word does not exist, return 0.

    Note: A word is defined as a character sequence
     consists of non-space characters only.

    For example,
    Given s = "Hello World",
    return 5.

    https://leetcode.com/problems/length-of-last-word/

\end{lstlisting}

\textbf{Solution}

~~Counting from backward will benefit a lot.

\javacode{Pro58}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 118 Pascal's Triangle
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 118 Pascal's Triangle}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given numRows, generate the first numRows of Pascal's triangle.

    For example, given numRows = 5,
    Return

    [
         [1],
        [1,1],
       [1,2,1],
      [1,3,3,1],
     [1,4,6,4,1]
    ]

    https://leetcode.com/problems/pascals-triangle/

\end{lstlisting}

\textbf{Solution}

~~Such an easy problem.

\javacode{Pro118}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 119 Pascal's Triangle II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 119 Pascal's Triangle II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an index k, return the kth row of the Pascal's triangle.

    For example, given k = 3,
    Return [1,3,3,1].

    Note:
    Could you optimize your algorithm to use only O(k) extra space?

    https://leetcode.com/problems/pascals-triangle-ii/

\end{lstlisting}

\textbf{Solution}

~~Such an easy problem, too.

\javacode{Pro119}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 6 ZigZag Conversion
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 6 ZigZag Conversion}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    The string "PAYPALISHIRING" is written in a zigzag pattern
     on a given number of rows like this:
      (you may want to display this pattern
       in a fixed font for better legibility)

    P   A   H   N
    A P L S I I G
    Y   I   R
    And then read line by line: "PAHNAPLSIIGYIR"
    Write the code that will take a string and
     make this conversion given a number of rows:

    string convert(string text, int nRows);
    convert("PAYPALISHIRING", 3) should return "PAHNAPLSIIGYIR".

    https://leetcode.com/problems/zigzag-conversion/

\end{lstlisting}

\textbf{Solution}

~~Such an easy problem, three, find the rule and the problem can be solved easily.

\javacode{Pro6}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 273 Integer to English Words
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 273 Integer to English Words}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Convert a non-negative integer to its english words representation.
     Given input is guaranteed to be less than 231 - 1.

    For example,
    123 -> "One Hundred Twenty Three"
    12345 -> "Twelve Thousand Three Hundred Forty Five"
    1234567 ->
     "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
    Hint:

    Did you see a pattern in dividing the number into chunk of words? For example,
     123 and 123000.
    Group the number by thousands (3 digits).
     You can write a helper function that takes a number
      less than 1000 and convert just that chunk to words.
    There are many edge cases. What are some good test cases?
     Does your code work with input such as 0? Or 1000010?
      (middle chunk is zero and should not be printed out)

    https://leetcode.com/problems/integer-to-english-words/

\end{lstlisting}

\textbf{Solution}

~~Hint is enough for solving the problem, honestly. But, never enough for all the edge cases(especially when involved with spaces).

\javacode{Pro273}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 310 Minimum Height Trees
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 310 Minimum Height Trees}}

\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    For a undirected graph with tree characteristics,
     we can choose any node as the root.
      The result graph is then a rooted tree.
       Among all possible rooted trees,
       those with minimum height are called minimum height trees (MHTs).
        Given such a graph,
         write a function to find all the MHTs and return a list of their root labels.

    Format
    The graph contains n nodes which are labeled from 0 to n - 1.
    You will be given the number n and a list of undirected edges
     (each edge is a pair of labels).

    You can assume that no duplicate edges will appear in edges.
     Since all edges are undirected, [0, 1] is the same as [1, 0]
      and thus will not appear together in edges.

    Example 1:

    Given n = 4, edges = [[1, 0], [1, 2], [1, 3]]

            0
            |
            1
           / \
          2   3
    return [1]

    Example 2:

    Given n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]

         0  1  2
          \ | /
            3
            |
            4
            |
            5
    return [3, 4]

    Hint:

    How many MHTs can a graph have at most?
    Note:

    (1) According to the definition of tree on Wikipedia:
     ``a tree is an undirected graph in which any two vertices
      are connected by exactly one path. In other words,
       any connected graph without simple cycles is a tree.''

    (2) The height of a rooted tree is the number of edges
     on the longest downward path between the root and a leaf.

    https://leetcode.com/problems/minimum-height-trees/

\end{lstlisting}

\textbf{Solution}

~~The idea is like topological sort, since this is an undirected graph, find the node with degree of 1, remove them from the graph, until 1 or 2 nodes left.

~~ Back news is: I used `while (remaining$ >$ 2)' to check if I get the result, which means I'm not totally understanding it.

~~ Take care when n == 1.

\javacode{Pro310}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 300 Longest Increasing Subsequence
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 300 Longest Increasing Subsequence}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an unsorted array of integers,
     find the length of longest increasing subsequence.

    For example,
    Given [10, 9, 2, 5, 3, 7, 101, 18],
    The longest increasing subsequence is [2, 3, 7, 101],
     therefore the length is 4.
      Note that there may be more than one LIS combination,
       it is only necessary for you to return the length.

    Your algorithm should run in O(n2) complexity.

    Follow up: Could you improve it to O(n log n) time complexity?

    https://leetcode.com/problems/longest-increasing-subsequence/

\end{lstlisting}

\textbf{Solution}

~~As for the $O(n^2)$ solution, it is an easy DP problem, start of LCS(Longest Common Substring/Sub-sequence).

~~However, optimizing it to $O(n logn)$ is tricky.

~~First, the $O(n^2)$ solution.

\javacode{Pro300_1_1}{Solution 1.1}

~~Then the $O(n logn)$ solution. The key insight is to find the $O(logn)$ factor. Below are train of thought from Discuss module:(or refer to this blog:)

~~\url{https://segmentfault.com/a/1190000003819886}

~~~~Runtime: To get an O(n log n ) runtime, I'm going to create a second list S. (Stick with me for now -- I'll get rid of it in a minute to get O(1) space.) I'll do a single pass through nums, and as I look at each element:

~~~~The length of S will be equal to the length of the longer subsequence I've found to that point.\\
~~~~The last element of S will be the last element of that subsequence. (However, the earlier elements may no longer be part of that sequence -- S is not actually the subsequence itself.)\\
~~~~At the end, the length of S will be our solution.

~~~~S will be sorted at all times. Each new element is inserted into S, replacing the smallest element in S that is not smaller than it (which we can find with a binary search). If that element is larger than the last element of S, then we extend S by one -- maintaining both properties.

~~~~For example, if

~~~~~~nums = [5,6,7,1,2,8,3,4,0,5,9]\\
~~~~then after we prcoess the 7:

~~~~~~S = [5,6,7]\\
~~~~after we process the 2:

~~~~~~S = [1,2,7]\\
~~~~after we process the 8:

~~~~~~S = [1,2,7,8]\\
~~~~Then we process the 3:

~~~~~~S = [1,2,3,8]\\
~~~~We process the 4:

~~~~~~S = [1,2,3,4]\\
~~~~and now the next three elements:

~~~~~~S = [0,2,3,4,5,9]\\
~~~~\textbf{S is not the actual subsequence}, but it is the right length (end ends in the right number).

~~We are making n passes, and doing a binary search each time. So $O(n log n)$ time.

~~Space: Assuming we are allowed to destroy the list, we don't need S. Since S will never be larger then the number of elements we have looked at, and we only need to look at each element once, we can just use the beginning of nums for S (keeping track of the size of ``S'' in a separate variable.

\javacode{Pro300_1_2}{Solution 1.2}

~~ Moreover, if we want to recover the actual subsequence, we may need to do some extra work. My solution is to maintain a LinkedList for each position, when there is a element bigger than former ones coming, add -1 to its head, the number of -1 depends on the maximum depth of former linked list. See code in listing \ref{Pro300_1_3}

\javacode{Pro300_1_3}{Solution 1.2 - Recover actual subsequence}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 334 Increasing Triplet Subsequence
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 334 Increasing Triplet Subsequence}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an unsorted array return whether an increasing subsequence
     of length 3 exists or not in the array.

    Formally the function should:
    Return true if there exists i, j, k
    such that arr[i] < arr[j] < arr[k] given 0 <= i < j < k <= n-1 else return false.
    Your algorithm should run in O(n) time complexity and O(1) space complexity.

    Examples:
    Given [1, 2, 3, 4, 5],
    return true.

    Given [5, 4, 3, 2, 1],
    return false.

    https://leetcode.com/problems/increasing-triplet-subsequence/

\end{lstlisting}

\textbf{Solution}

~~Use idea of Solution 1.2 of Problem ``Longest Increasing Subsequence'', by having smaller, larger integers to store current minimum element and second smallest element after the minimum element, if there is another element larger than larger(2nd smallest after smallest/ or maybe before smallest, but has another smaller element ahead), there will be an increasing sequence with the length of 3.

\javacode{Pro334}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 368 Largest Divisible Subset
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 368 Largest Divisible Subset}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a set of distinct positive integers,
     find the largest subset such that every pair (Si, Sj) of elements
      in this subset satisfies: Si % Sj = 0 or Sj % Si = 0.
    If there are multiple solutions, return any subset is fine.
    Example 1:
    nums: [1,2,3]

    Result: [1,2] (of course, [1,3] will also be ok)

    Example 2:
    nums: [1,2,4,8]

    Result: [1,2,4,8]

    https://leetcode.com/problems/largest-divisible-subset/

\end{lstlisting}

\textbf{Solution}

~~ Follow the similar solution for `Longest Increasing Subsequence'. $O(n^2)$ complexity. Can probably be optimized a bit to track both previous element and max length of path using array instead of creating arrays of Set/List.

\javacode{Pro368}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 208 Implement Trie (Prefix Tree)
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 208 Implement Trie (Prefix Tree)}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Implement a trie with insert, search, and startsWith methods.

    https://leetcode.com/problems/implement-trie-prefix-tree/

\end{lstlisting}

\textbf{Solution}

~~The problem itself is not difficult at all, but Trie(Prefix Tree) is what we need to know.

~~\includegraphics[width=1\columnwidth]{figures/208_implement_trie}

\javacode{Pro208}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 211 Add and Search Word - Data structure design
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 211 Add and Search Word - Data structure design}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Design a data structure that supports the following two operations:

    void addWord(word)
    bool search(word)
    search(word) can search a literal word or a regular expression string
     containing only letters a-z or ..
     A . means it can represent any one letter.

    For example:

    addWord("bad")
    addWord("dad")
    addWord("mad")
    search("pad") -> false
    search("bad") -> true
    search(".ad") -> true
    search("b..") -> true
    Note:
    You may assume that all words are consist of lowercase letters a-z.


    You should be familiar with how a Trie works.
     If not, please work on this problem: Implement Trie (Prefix Tree) first.

    https://leetcode.com/problems/add-and-search-word-data-structure-design/

\end{lstlisting}

\textbf{Solution}

~~Not the same as Problem ``Implement Trie'', a bit more difficult, use a recursive solution to solve the problem.

\javacode{Pro211}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 79 Word Search
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 79 Word Search}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a 2D board and a word, find if the word exists in the grid.

    The word can be constructed from letters of sequentially adjacent cell,
     where "adjacent" cells are those horizontally or vertically neighboring.
      The same letter cell may not be used more than once.

    For example,
    Given board =

    [
      ['A','B','C','E'],
      ['S','F','C','S'],
      ['A','D','E','E']
    ]
    word = "ABCCED", -> returns true,
    word = "SEE", -> returns true,
    word = "ABCB", -> returns false.

    https://leetcode.com/problems/word-search/

\end{lstlisting}

\textbf{Solution}

~~Problem 79.

~~Solution is using straightforward backtracking method, be sure to return as soon as we get result, otherwise will get a TLE error.(I stuck in misusing $\vert\vert$ as $\vert$).

\javacode{Pro79}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 212 Word Search II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 212 Word Search II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a 2D board and a list of words from the dictionary,
     find all words in the board.

    Each word must be constructed from letters of sequentially adjacent cell,
     where "adjacent" cells are those horizontally or vertically neighboring.
      The same letter cell may not be used more than once in a word.

    For example,
    Given words = ["oath","pea","eat","rain"] and board =

    [
      ['o','a','a','n'],
      ['e','t','a','e'],
      ['i','h','k','r'],
      ['i','f','l','v']
    ]
    Return ["eat","oath"].
    Note:
    You may assume that all inputs are consist of lowercase letters a-z.

    click to show hint.

    You would need to optimize your backtracking to pass the larger test.
     Could you stop backtracking earlier?

    If the current candidate does not exist in all words' prefix,
     you could stop backtracking immediately.
      What kind of data structure could answer such query efficiently?
       Does a hash table work? Why or why not? How about a Trie?
        If you would like to learn how to implement a basic trie,
         please work on this problem: Implement Trie (Prefix Tree) first.

    https://leetcode.com/problems/word-search-ii/

\end{lstlisting}

\textbf{Solution}

~~This is the first problem I cannot finish for the first time!! Because I even cannot finish the testing of big data in Eclipse! More than 65536 bytes! And it stuck my computer!

~~ For optimizations, see

\url{https://leetcode.com/discuss/77851/java-15ms-easiest-solution-100-00%25}

~~~~Some notes:
\\
~~~~~~Combing them, Trie is the natural choice. Notice that:
\\
~~~~~~TrieNode is all we need. search and startsWith are useless.\\
~~~~~~No need to store character at TrieNode. c.next[i] != null is enough.\\
~~~~~~Never use c1 + c2 + c3. Use StringBuilder.\\
~~~~~~No need to use $O(n^2)$ extra space visited[m][n].\\
~~~~~~No need to use StringBuilder. Storing word itself at leaf node is enough.\\
~~~~~~No need to use HashSet to de-duplicate. Use "one time search" trie.\\
\\
\\
~~~~Some optimizations:
\begin{enumerate}
    \item 59ms: Use search and startsWith in Trie class like this popular solution.
    \item 33ms: Remove Trie class which unnecessarily starts from root in every dfs call.
    \item 30ms: Use w.toCharArray() instead of w.charAt(i).
    \item 22ms: Use StringBuilder instead of c1 + c2 + c3.
    \item 20ms: Remove StringBuilder completely by storing word instead of boolean in TrieNode.
    \item 20ms: Remove visited[m][n] completely by modifying board[i][j] = '\#' directly.
    \item 18ms: check validity, e.g., if(i $>$ 0) dfs(...), before going to the next dfs.
    \item 17ms: De-duplicate c - a with one variable i.
    \item 15ms: Remove HashSet completely. dietpepsi's idea is awesome.
\end{enumerate}

~~I'll list my solution and optimized solution on my note.

\javacode{Pro212_1_1}{My Solution}

~~ And a much better solution.

\javacode{Pro212_1_2}{Better Solution}

~~~(BTW. I solved this problem using his TrieNode...)

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 139 Word Break
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 139 Word Break}}

\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given a string s and a dictionary of words dict,
     determine if s can be segmented into a space-separated sequence
      of one or more dictionary words.

    For example, given
    s = "leetcode",
    dict = ["leet", "code"].

    Return true because "leetcode" can be segmented as "leet code".

    https://leetcode.com/problems/word-break/

\end{lstlisting}

\textbf{Solution}

~~A DP problem, not so difficult if you know the key idea of solution.

~~ The state transition equation is like dp[i+word.length()] = dp[i], where s.substring(i, i+word.length()).equals(word).

\javacode{Pro139}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 140 Word Break II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 140 Word Break II}}

\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given a string s and a dictionary of words dict,
     add spaces in s to construct a sentence where
      each word is a valid dictionary word.

    Return all such possible sentences.

    For example, given
    s = "catsanddog",
    dict = ["cat", "cats", "and", "sand", "dog"].

    A solution is ["cats and dog", "cat sand dog"].

    https://leetcode.com/problems/word-break-ii/

\end{lstlisting}

\textbf{Solution}

~~First have a glance at Problem ``Work Break'', on how to finish the split process.

~~ For this problem, we should also maintain the dp array, but this time not boolean, but String, a list of String to be more specific. dp[i] is the list of words in dictionary ends at index i with similar train of thought as ``Word Break'';

~~ Finally, use dfs to combine all possibilities.

\javacode{Pro140}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 127 Word Ladder
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 127 Word Ladder}}

\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given two words (beginWord and endWord),
     and a dictionary's word list,
      find the length of shortest transformation sequence
       from beginWord to endWord, such that:

    Only one letter can be changed at a time
    Each intermediate word must exist in the word list
    For example,

    Given:
    beginWord = "hit"
    endWord = "cog"
    wordList = ["hot","dot","dog","lot","log"]
    As one shortest transformation is
         "hit" -> "hot" -> "dot" -> "dog" -> "cog",
    return its length 5.

    Note:
        Return 0 if there is no such transformation sequence.
        All words have the same length.
        All words contain only lowercase alphabetic characters.

    https://leetcode.com/problems/word-ladder/

\end{lstlisting}

\textbf{Solution}

~~First we may realize that this is a graph(undirected) problem using BFS. Two nodes are neighbors when they have an distance of 1(Only one letter differs).  So we may write code as below:

\javacode{Pro127_1_1}{TLE Solution}

~~ A simplified method is to avoid process that generates a graph. Still a BFS framework, but this time a different method. Substitute each letter of a word from `a' to `z' to see if generated word exists in dictionary, which is in nature same as former solution, but has a better performance when the count of word is large(since few of them are of 1 distance, we waste our time comparing them) and word is short.

~~ However, a one-pass solution will also get TLE error. So we need to optimize it further. Do it with 2 pass. Go from both sourceSet and targetSet, set the shorter one to `sourceSet', guaranteeing that we are always searching from a shorter set, which will accelerate our execution.

\javacode{Pro127_1_2}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 126 Word Ladder II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 126 Word Ladder II}}

\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given two words (beginWord and endWord),
     and a dictionary's word list,
      find all shortest transformation sequence(s)
       from beginWord to endWord, such that:

    Only one letter can be changed at a time
    Each intermediate word must exist in the word list
    For example,

        Given:
        beginWord = "hit"
        endWord = "cog"
        wordList = ["hot","dot","dog","lot","log"]
        Return
          [
            ["hit","hot","dot","dog","cog"],
            ["hit","hot","lot","log","cog"]
          ]
    Note:
        All words have the same length.
        All words contain only lowercase alphabetic characters.

    https://leetcode.com/problems/word-ladder-ii/

\end{lstlisting}

\textbf{Solution}

~~Similar to Problem ``Word Ladder'', still a two-pass method, set beginWords the shorter set which will reduce the time burden.

~~Building the result path is another tricky part(which is maybe more tricky). Generating a HashMap with key of source String and value of strings it can generated by just changing one letter of the word is able to solve the problem. Just DFS the Map, we will get the final result.

\javacode{Pro126}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 5 Longest Palindromic Substring
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 5 Longest Palindromic Substring}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given a string S,
     find the longest palindromic substring in S.
      You may assume that the maximum length of S is 1000,
       and there exists one unique longest palindromic substring.

    https://leetcode.com/problems/longest-palindromic-substring/

\end{lstlisting}

\textbf{Solution - DP}

~~First solution is DP solution with $O(n^2)$, it can output a result through `Run'(within an acceptable time limit, I guess), but will get TLE when submit.

~~ Mention the variables in loop - len and i rather than i and j since we should get dp value of shorter string first to get longer ones.

\javacode{Pro5_1}{Solution 1}

\textbf{Solution - Expanding}

~~Solution is an $O(n^2) runtime$ solution. The train of thought is interesting and reversing. Instead of finding the longest, the solution start from the middle of palindrome and form a palindrome from the middle. Note that there are two ways of expanding the middle element(s), one from single element, while another from two adjacent elements.

\javacode{Pro5_2}{Solution 2}

\textbf{Solution - Manacher}

~~Such a neat, elegant, excellent algorithm that I still cannot totally understand it...

~~ Though there is a blog for Manacher in Chinese, I think the English version in Leetcode articles is much better.(Maybe with the example?) I'll post the screenshots and code here for future use.

\includegraphics[width=0.72\columnwidth]{figures/5_longest_palindromic_substring_1}\\
\includegraphics[width=0.72\columnwidth]{figures/5_longest_palindromic_substring_2}\\
\includegraphics[width=0.72\columnwidth]{figures/5_longest_palindromic_substring_3}\\
\includegraphics[width=0.72\columnwidth]{figures/5_longest_palindromic_substring_4}\\

\javacode{Pro5_3}{Solution 3}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 221 Maximal Square
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 221 Maximal Square}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given a 2D binary matrix filled with 0's and 1's,
     find the largest square containing all 1's and return its area.

    For example, given the following matrix:

    1 0 1 0 0
    1 0 1 1 1
    1 1 1 1 1
    1 0 0 1 0
    Return 4.

    https://leetcode.com/problems/maximal-square/

\end{lstlisting}

\textbf{Solution}

~~A simple DP problem. Take care of the input: not int[][] matrix, but char[][] matrix.

\javacode{Pro221}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 84 Largest Rectangle in Histogram
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 84 Largest Rectangle in Histogram}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given n non-negative integers representing the histogram's bar
     height where the width of each bar is 1,
      find the area of largest rectangle in the histogram.


    Above is a histogram where width of each bar is 1,
     given height = [2,1,5,6,2,3].


    The largest rectangle is shown in the shaded area,
     which has area = 10 unit.

    For example,
    Given heights = [2,1,5,6,2,3],
    return 10.

    https://leetcode.com/problems/largest-rectangle-in-histogram/

\end{lstlisting}

\includegraphics[width=0.25\columnwidth]{figures/84_largest_rectangle_in_histogram_1}

\includegraphics[width=0.25\columnwidth]{figures/84_largest_rectangle_in_histogram_2}

\textbf{Solution}

~~A simple train of thought is like Problem ``Longest Palindromic Substring'', by starting from middle and expand to both sides. However, when there is a set of big data with similar values, we have to compute nearly all values for $n^2$, which will of course lead to TLE.

\javacode{Pro84_1}{TLE solution}

~~ There is another brilliant train of thought of dealing with this problem.

~~Use a `ascending stack' to solve the problem. Iterate along array, when heights[idx] is larger than top element of stack, push it; otherwise pop all elements larger than current element, and since popped elements are in descending order, we can just use (height of popped element * width++) to get a potential maximum rectangle. The width of rectangle is another difficulty, see figure.

~~\includegraphics[width=0.8\columnwidth]{figures/84_largest_rectangle_in_histogram_3}

\javacode{Pro84_2}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 85 Maximal Rectangle
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 85 Maximal Rectangle}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given a 2D binary matrix filled with 0's and 1's,
     find the largest rectangle containing all ones and return its area.

    https://leetcode.com/problems/maximal-rectangle/

\end{lstlisting}

\textbf{Solution}

~~Inspired by Problem ``Largest Rectangle in Histogram'', the problem can be transformed to a problem doing m(m is the total number of rows) times with algorithm in previous problem.(Think of why)

\javacode{Pro85}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 43 Multiply Strings
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 43 Multiply Strings}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given two numbers represented as strings,
     return multiplication of the numbers as a string.

    Note: The numbers can be arbitrarily large and are non-negative.

    https://leetcode.com/problems/multiply-strings/

\end{lstlisting}

\textbf{Solution}

~~I unexpectedly solve the problem in just one attempt!

~~ However, I missed the given condition that numbers are non-negative, which means I forgot to consider the negative numbers at first sight(but I do consider the 0 result).

\javacode{Pro43}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 29 Divide Two Integers
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 29 Divide Two Integers}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Divide two integers without using multiplication,
     division and mod operator.

    If it is overflow, return MAX_INT.

    https://leetcode.com/problems/divide-two-integers/

\end{lstlisting}

\textbf{Solution}

~~At first sight I thought this is a problem similar to ``Multiply Strings'', however, this is indeed a Math and Binary Search problem.

~~Without division and multiplication, remaining operators are +, - , and bit operators. The most straightforward way is to reduce divisor from dividend until remaining number is less than divisor, which will get TLE.

~~Have you noticed that, $<<$ 1 is the same as * 2? That's the key insight to this problem. See code in listing.(There are still many edge cases!)

~~Something to take care. See in the listing, use `divisor $<= (dividend >> 1)$' instead of `dividend $<$ divisor', the latter will take 903ms to calculate Integer.MAX\_VALUE $/$ 2 while the former takes 0ms...

\javacode{Pro29}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 36 Valid Sudoku
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 36 Valid Sudoku}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Determine if a Sudoku is valid, according to:
     Sudoku Puzzles - The Rules.

    The Sudoku board could be partially filled,
     where empty cells are filled with the character '.'.


    A partially filled sudoku which is valid.

    Note:
    A valid Sudoku board (partially filled)
     is not necessarily solvable.
      Only the filled cells need to be validated.

    https://leetcode.com/problems/valid-sudoku/

\end{lstlisting}

\includegraphics[width=0.3\columnwidth]{figures/36_valid_sudoku}

\textbf{Solution}

~~ It's an easy problem, use 3 arrays to validate value on rows, columns and grids(with 3 * 3 size) are used.

~~ Description in Note makes the problem even easier.

\javacode{Pro36}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 37 Sudoku Solver
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 37 Sudoku Solver}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Write a program to solve a Sudoku puzzle by filling the empty cells.

    Empty cells are indicated by the character '.'.

    You may assume that there will be only one unique solution.


    A sudoku puzzle...


    ...and its solution numbers marked in red.

    https://leetcode.com/problems/sudoku-solver/

\end{lstlisting}


\includegraphics[width=0.2\columnwidth]{figures/37_sudoku_solver_1}
\includegraphics[width=0.2\columnwidth]{figures/37_sudoku_solver_2}

\textbf{Solution}

~~Just like ``N-Queens'', pre-processing will much accelerate the speed.

\javacode{Pro37}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 34 Search for a Range
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 34 Search for a Range}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given a sorted array of integers,
     find the starting and ending position of a given target value.

    Your algorithm's runtime complexity must be in the order of O(log n).

    If the target is not found in the array, return [-1, -1].

    For example,
    Given [5, 7, 7, 8, 8, 10] and target value 8,
    return [3, 4].

    https://leetcode.com/problems/search-for-a-range/

\end{lstlisting}

\textbf{Solution}

~~Binary search problem. The key to problem is to do binary search twice.

\javacode{Pro34}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 209 Minimum Size Subarray Sum
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 209 Minimum Size Subarray Sum}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given an array of n positive integers and a positive integer s,
     find the minimal length of a subarray of which the sum >= s.
      If there isn't one, return 0 instead.

    For example, given the array [2,3,1,2,4,3] and s = 7,
    the subarray [4,3] has the minimal length under the problem constraint.

    click to show more practice.

    More practice:
    If you have figured out the O(n) solution,
     try coding another solution of which the time complexity is O(n log n).

    https://leetcode.com/problems/search-for-a-range/

\end{lstlisting}

\textbf{Solution 1}

~~Use 2 pointers to maintain the sum and check if less than current minimum condition.

~~ $O(n)$ solution.

\javacode{Pro209_1}{Solution 1}

\textbf{Solution 2}

~~Second solution is to use binary search to find proper length to calculate the sum. See listing.

~~ The $O(n logn)$ solution.

\javacode{Pro209_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 292 Nim Game
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 292 Nim Game}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    You are playing the following Nim Game with your friend:
     There is a heap of stones on the table,
      each time one of you take turns to remove 1 to 3 stones.
       The one who removes the last stone will be the winner.
        You will take the first turn to remove the stones.

    Both of you are very clever and have optimal strategies for the game.
     Write a function to determine whether
      you can win the game given the number of stones in the heap.

    For example, if there are 4 stones in the heap,
     then you will never win the game:
      no matter 1, 2, or 3 stones you remove,
       the last stone will always be removed by your friend.

    Hint:

    If there are 5 stones in the heap, could you figure out
     a way to remove the stones such that you will always be the winner?

    https://leetcode.com/problems/nim-game/

\end{lstlisting}

\textbf{Solution}

~~An interesting problem with a solution with only one line!! Solved by myself!

\javacode{Pro292}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 290 Word Pattern
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 290 Word Pattern}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given a pattern and a string str, find if str follows the same pattern.

    Here follow means a full match, such that there is a bijection
     between a letter in pattern and a non-empty word in str.

    Examples:
    pattern = "abba", str = "dog cat cat dog" should return true.
    pattern = "abba", str = "dog cat cat fish" should return false.
    pattern = "aaaa", str = "dog cat cat dog" should return false.
    pattern = "abba", str = "dog dog dog dog" should return false.
    Notes:
    You may assume pattern contains only lowercase letters,
     and str contains lowercase letters separated by a single space.

    https://leetcode.com/problems/word-pattern/

\end{lstlisting}

\textbf{Solution}

~~Not difficult, solved by Set and a array(similar to a Hashmap)

~~ Someone solved it by a Set and 2 Hashmaps...

\javacode{Pro290}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 316 Remove Duplicate Letters
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 316 Remove Duplicate Letters}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given a string which contains only lowercase letters,
     remove duplicate letters so that every letter appear once and only once.
      You must make sure your result is the smallest
       in lexicographical order among all possible results.

    Example:
    Given "bcabc"
    Return "abc"

    Given "cbacdcbc"
    Return "acdb"

    https://leetcode.com/problems/remove-duplicate-letters/

\end{lstlisting}

\textbf{Solution}`

~~ List the train of thought as below:

\begin{enumerate}
    \item Calculate a array of count where that how many times each letter appears.
    \item Find a non-repeating sequence, break the iterating when any character has no successors using the count array maintained.
    \item Get the smallest letter in sequence, remove letters in front of it and all same letters behind the element.
    \item Iterate to get next element.
\end{enumerate}

~~ Solution description in Chinese can be seen

 \url{https://segmentfault.com/a/1190000004188227}.

\javacode{Pro316}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 89 Gray Code
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 89 Gray Code}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    The gray code is a binary numeral system where
     two successive values differ in only one bit.

    Given a non-negative integer n representing
     the total number of bits in the code,
      print the sequence of gray code.
       A gray code sequence must begin with 0.

    For example, given n = 2, return [0,1,3,2].
     Its gray code sequence is:

    00 - 0
    01 - 1
    11 - 3
    10 - 2
    Note:
    For a given n, a gray code sequence is not uniquely defined.

    For example, [0,2,3,1] is also a valid gray code sequence
     according to the above definition.

    For now, the judge is able to judge based on one instance of
     gray code sequence. Sorry about that.

    https://leetcode.com/problems/gray-code/

\end{lstlisting}

\textbf{Solution}

~~Consider when n=2 and n=3

~~ When n=2, the sequence is 0,1,3,2, namely 00,01,11,10

~~ When n=3, the sequence is 0\textbf{00},0\textbf{01},0\textbf{11},0\textbf{10},1\textbf{10},1\textbf{11},1\textbf{01},1\textbf{00}, just the sequence from 2 and add 1 to the front reversely.

\javacode{Pro89_1_1}{Solution 1.1}

~~There is even a solution looks like this.

\javacode{Pro89_1_2}{Solution 1.2}

~~ Another alternative solution.

\includegraphics[width=0.8\columnwidth]{figures/89_gray_code}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 134 Gas Station
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 134 Gas Station}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    There are N gas stations along a circular route,
     where the amount of gas at station i is gas[i].

    You have a car with an unlimited gas tank and
     it costs cost[i] of gas to travel from station i
      to its next station (i+1).
       You begin the journey with an empty tank at one of the gas stations.

    Return the starting gas station's index
     if you can travel around the circuit once, otherwise return -1.

    Note:
    The solution is guaranteed to be unique.

    https://leetcode.com/problems/gas-station/

\end{lstlisting}

\textbf{Solution 1}

~~First, get all diffs by gas[i] \& cost[i], which tells us how much oil will be left after one station.

~~ Then, do you realize that the problem has been transformed into a problem finding the sub-array with maximum sum, but in a \textbf{circular} array.

~~ (BTW, how to deal with subarray problems, refer to

 \url{http://blog.csdn.net/hcbbt/article/details/10454947})

 ~~~Back to the problem. We have known how to solve sub-array problems, how about circular array?!

 ~~ Don't be afraid(since I'm stuck for such a long while). The difficulty lays on how to find max sum of subarray starts from latter half of array and ends at former half of it. How about get the minimum of current array? The total sum is given, minimum sum means maximum on the other side. What we need to do differently from sequential problems is to check which one is larger, max or totalSum-min.

\javacode{Pro134_1}{Solution 1}

\textbf{Solution 2}

~~Another solution is the jump solution.

\javacode{Pro134_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 135 Candy
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 135 Candy}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    There are N children standing in a line.
    Each child is assigned a rating value.

    You are giving candies to these children
     subjected to the following requirements:

    Each child must have at least one candy.
    Children with a higher rating get more candies than their neighbors.
    What is the minimum candies you must give?

    https://leetcode.com/problems/candy/

\end{lstlisting}

\textbf{Solution 1}

~~Solution 1 is greedy. Iterating from front to end, when there is a pair which ratings[i] $<$ ratings[i + 1], give candies[i] = 1 OR stay unchanged; give candies[i + 1] = candies[i] + 1; Then iterate backward, doing the similar operation, except for the condition when the $i^{th}$ people has already been given the candies, that's when we give the man max{candies[i] , candies[i + 1] + 1}.

~~ Finally, don't forget to give all children who aren't given any candies 1 candy for comfort.(Consider the input of [2,2,1])

\javacode{Pro135_1}{Solution 1}

\textbf{Solution 2}

~~Solution 2 is tactical and can avoid using extra $O(n) space$. Let's consider the non-descending condition - [1,2,3,4,5] OR [1,2,3,3,4], when the sequence is ascending, we don't need to worry about the candy-giving thing, since the result is obvious after one pass - [1,2,3,4,5] \& [1,2,3,1,2]. Now consider something more complicated - [1,5,4,3,2], still we give $kid_0$(with rating of 1) 1 candy, $kid_1$ 2 candies temporarily, then we meet $kid_2$ with 4 ratings, give him 1(we'll know why afterwards), and now we are in a descending sequence with length of 2 by now.

~~Then the important part. We meet $kid_3$ with 3 ratings, which is still in the descending sequence, and that's when we know we have underestimated $kid_1$, so we give him an extra candy, namely total++; don't forget $kid_3$, we give him 2 candies(here we are balancing $kid_2$ and $kid_3$, in fact $kid_2$ is the one who should get 2 candies by now, not $kid_3$, since we are calculating the total amount of candies, so it doesn't matter who get the candy.) Similarly, when $kid_4$ arrives, we give him(or $kid_2$, to be more precious) 3 candies and compensate $kid_1$ again.

\javacode{Pro135_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 205 Isomorphic Strings
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 205 Isomorphic Strings}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given two strings s and t,
     determine if they are isomorphic.

    Two strings are isomorphic if
     the characters in s can be replaced to get t.

    All occurrences of a character must be replaced with
     another character while preserving the order of characters.
      No two characters may map to the same character but
       a character may map to itself.

    For example,
    Given "egg", "add", return true.

    Given "foo", "bar", return false.

    Given "paper", "title", return true.

    Note:
    You may assume both s and t have the same length.

    https://leetcode.com/problems/isomorphic-strings/

\end{lstlisting}

\textbf{Solution}

~~An easy problem using HashMap..... Wait a minute! HashMaps(or a map with a set)! Consider when the input is ``ab'' \& ``aa''.

\javacode{Pro205}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 4 Median of Two Sorted Arrays
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 4 Median of Two Sorted Arrays}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    There are two sorted arrays nums1 and nums2 of
     size m and n respectively.
      Find the median of the two sorted arrays.
       The overall run time complexity should be O(log (m+n)).

    https://leetcode.com/problems/median-of-two-sorted-arrays/

\end{lstlisting}

\textbf{Solution 1}

~~Honestly, this is not a correct solution though it got AC on OJ. The complexity is $O(m+n)$ rather than $O(log(m+n))$.

\javacode{Pro4_1}{Solution 1}

\textbf{Solution 2}

~~ Solution 2 makes use of Binary Search, with a pretty complicated process on calculating the related index.

~~ The train of thought is quite interesting.

~~ For detailed description on solution , visit \url{http://blog.csdn.net/zxzxy1988/article/details/8587244}

\javacode{Pro4_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 295 Find Median from Data Stream
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 295 Find Median from Data Stream}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Median is the middle value in an ordered integer list.
     If the size of the list is even, there is no middle value.
      So the median is the mean of the two middle value.

    Examples:
    [2,3,4] , the median is 3

    [2,3], the median is (2 + 3) / 2 = 2.5

    Design a data structure that supports the following two operations:

    void addNum(int num) - Add a integer number from the data stream
                             to the data structure.
    double findMedian() - Return the median of all elements so far.
    For example:

    add(1)
    add(2)
    findMedian() -> 1.5
    add(3)
    findMedian() -> 2

    https://leetcode.com/problems/find-median-from-data-stream/

\end{lstlisting}

~~Though almost all solutions on Internet like CSDN has only one way to solve this - using two heaps, one max heap and one min heap, this is still a problem worth 2+ hours to think carefully about it, to be honest.

\textbf{Solution 1 - Array \& List}

~~ Unsorted array is enough for the problem. Partition is what we usually do in QuickSort, so as to finish the task of finding the median. Partition is of $O(n)\ runtime$, where inserting to unsorted array only costs $O(1)$. This method will get TLE in OJ.

\javacode{Pro295_1_1}{Solution 1.1 - Unsorted Array}

~~Sorted array may make getting median faster(but inserting elements to container slower). Inserting an element to the array and keep it sorted needs $O(1) runtime$, but getting median only need $O(1) runtime.$ This solution gets AC in OJ.

\javacode{Pro295_1_2}{Solution 1.2 - Sorted Array}

~~ What's more, we can use Sorted List to solve the problem, adding 2 pointers pointing at 2 medians can reduce the complexity of getting median to $O(1)$(when the length is odd, the pointers point at the same element.)

\textbf{Solution 2 - Heaps(Max \& Min) in form of PriorityQueue}

~~Solution is more proper to solve the problem.

~~ Maintain 2 heaps, one max and another min. Keep them have the same size or max heap is 1 element larger than min heap in size. We store the biggest k elements in min heap while the others(k OR k + 1) in max heap. Then either the median is root of max heap OR average of roots from both trees.

~~ How to maintain their sizes? We always push eleme

\javacode{Pro295_2}{Solution 2 - Heaps}

\textbf{Solution3 - Trees(BST, Binary Search Tree OR AVL Tree)}

~~ Since in Java there are no built-in structures similar to BST or AVL, so I won't list the code here, just think of how to finish out task.

~~We may add a field in TreeNode to make searching for median faster(to $O(log n)$).

~~ To avoid the worst condition of BST, we may use AVL- the highly balanced tree structure to finish what BST need to do.

~\\

~~In summary, all sorts of methods can be concluded as figure below,

\includegraphics[width=0.7\columnwidth]{figures/295_find_median_from_data_stream}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 17 Letter Combinations of a Phone Number
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 17 Letter Combinations of a Phone Number}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Given a digit string, return all possible letter combinations
     that the number could represent.

    A mapping of digit to letters (just like on the telephone buttons)
     is given below.



    Input:Digit string "23"
    Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
    Note:
    Although the above answer is in lexicographical order,
     your answer could be in any order you want.

    https://leetcode.com/problems/letter-combinations-of-a-phone-number/

\end{lstlisting}

\includegraphics[width=0.3\columnwidth]{figures/17_letter_combinations_of_a_phone_number}

\textbf{Solution}

~~ A backtracking problem, similar to Problem ``Combinations''.

\javacode{Pro17}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 71 Simplify Path
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 71 Simplify Path}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an absolute path for a file (Unix-style), simplify it.

    For example,
    path = "/home/", => "/home"
    path = "/a/./b/../../c/", => "/c"
    click to show corner cases.

    Corner Cases:
        Did you consider the case where path = "/../"?
        In this case, you should return "/".
        Another corner case is the path might
         contain multiple slashes '/' together, such as "/home//foo/".
        In this case, you should ignore redundant slashes
         and return "/home/foo".

    https://leetcode.com/problems/simplify-path/

\end{lstlisting}

\textbf{Solution}

~~ It's obvious that the problem is proper to be solved using Stack, there are 2 things to be taken into consideration:

~~~~1. Mind those corner cases.(See detailed cases in problem description)

~~~~2. Don't forget to reverse those remaining paths in Stack, /home/test will be in the order of ``test $->$ home'' in Stack.

\javacode{Pro71}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 22 Generate Parentheses
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 22 Generate Parentheses}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given n pairs of parentheses,
     write a function to generate all combinations of well-formed parentheses.

    For example, given n = 3, a solution set is:

    "((()))", "(()())", "(())()", "()(())", "()()()"

    https://leetcode.com/problems/generate-parentheses/

\end{lstlisting}

\textbf{Solution}

~~An easy backtracking problem, when remaining left parentheses number equals right number, we must pick left one so that there won't be illegal pairs; when left less than right, we can pick either left or right parentheses.

\javacode{Pro22}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 338 Counting Bits
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 338 Counting Bits}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a non negative integer number num.
     For every numbers i in the range 0 <= i <= num
      calculate the number of 1's in their binary representation and
       return them as an array.

    Example:
    For num = 5 you should return [0,1,1,2,1,2].

    Follow up:

    It is very easy to come up with a solution
     with run time O(n*sizeof(integer)).
      But can you do it in linear time O(n) /possibly in a single pass?
    Space complexity should be O(n).
    Can you do it like a boss? Do it without using
     any builtin function like __builtin_popcount in c++ or in any other language.
    Hint:

    You should make use of what you have produced already.
    Divide the numbers in ranges like [2-3], [4-7], [8-15] and so on.
     And try to generate new range from previous.
    Or does the odd/even status of the number
     help you in calculating the number of 1s?

    https://leetcode.com/problems/counting-bits/

\end{lstlisting}

\textbf{Solution}

~~There is a cycle within all numbers, [[[[0],1],10,11],100,101,110,111], eg, for 0,1,10,11, the 100,101,110,111 is just adding 1 in front of them.

\javacode{Pro338_1_1}{Solution 1.1}

~~Another solution, the train of thought is similar in nature with mine, simpler.

\javacode{Pro338_1_2}{Solution 1.2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 299 Bulls and Cows
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 299 Bulls and Cows}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    You are playing the following Bulls and Cows game with your friend:
     You write down a number and ask your friend to guess what the number is.
      Each time your friend makes a guess, you provide a hint that indicates
       how many digits in said guess match your secret number exactly
        in both digit and position (called "bulls") and
         how many digits match the secret number but
          locate in the wrong position (called "cows").
           Your friend will use successive guesses and hints to eventually
            derive the secret number.

    For example:

        Secret number:  "1807"
        Friend's guess: "7810"
    Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)
    Write a function to return a hint according to the secret number
     and friend's guess, use A to indicate the bulls and B to indicate the cows.
      In the above example, your function should return "1A3B".

    Please note that both secret number and friend's guess may
     contain duplicate digits, for example:

        Secret number:  "1123"
        Friend's guess: "0111"
    In this case, the 1st 1 in friend's guess is a bull,
     the 2nd or 3rd 1 is a cow, and your function should return "1A1B".
    You may assume that the secret number and your friend's guess only
     contain digits, and their lengths are always equal.

    https://leetcode.com/problems/bulls-and-cows/

\end{lstlisting}

\textbf{Solution}

~~ I'm following an easy simulation, deal with `A' \& `B' separately, but I think there is space for optimization.

~~ Last FREE Easy Problem solved till 3rd, Apr., 2016.

\javacode{Pro299}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 162 Find Peak Element
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 162 Find Peak Element}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    A peak element is an element that is greater than its neighbors.

    Given an input array where num[i] != num[i+1],
     find a peak element and return its index.

    The array may contain multiple peaks,
     in that case return the index to any one of the peaks is fine.

    You may imagine that num[-1] = num[n] = - infinity(since I cannot type the symbol here)

    For example, in array [1, 2, 3, 1], 3 is a peak element
     and your function should return the index number 2.

    Note:
    Your solution should be in logarithmic complexity.

    https://leetcode.com/problems/find-peak-element/

\end{lstlisting}

\textbf{Solution 1}

~~$O(n)$ method, simple simulation, sequential method.

\javacode{Pro162_1}{Solution 1}

\textbf{Solution 2}

~~Binary search will reduce the complexity to $O(log n)$.

\javacode{Pro162_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 318 Maximum Product of Word Lengths
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 318 Maximum Product of Word Lengths}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a string array words, find the maximum value of length
    (word[i]) * length(word[j]) where the two words do not share common letters.
     You may assume that each word will contain only lower case letters.
      If no such two words exist, return 0.

    Example 1:
    Given ["abcw", "baz", "foo", "bar", "xtfn", "abcdef"]
    Return 16
    The two words can be "abcw", "xtfn".

    Example 2:
    Given ["a", "ab", "abc", "d", "cd", "bcd", "abcd"]
    Return 4
    The two words can be "ab", "cd".

    Example 3:
    Given ["a", "aa", "aaa", "aaaa"]
    Return 0
    No such pair of words.

    https://leetcode.com/problems/maximum-product-of-word-lengths/

\end{lstlisting}

\textbf{Solution}

~~Use 26-bit integers to represent each word(since a \& aa means the same to us in this problem). For example, `abd' is 0000..001011, then we can know if two integers carry out bit and \& calculation and get a non-zero result, the two have some letters in common and vice versa.

\javacode{Pro318}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 164 Maximum Gap
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 164 Maximum Gap}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an unsorted array,
     find the maximum difference between the successive elements
      in its sorted form.

    Try to solve it in linear time/space.

    Return 0 if the array contains less than 2 elements.

    You may assume all elements in the array are
     non-negative integers and fit in the 32-bit signed integer range.

    https://leetcode.com/problems/maximum-gap/

\end{lstlisting}

\textbf{Solution}

~~Hard problem is worthy of its name... Though this problem is not so difficult to use Bucket Sort, there are so many edge cases and annoying index calculation.

~~ Back to the problem, the maximum gap can only appear between maximum and minimum value of 2 non-empty adjacent buckets, we can use this idea to solve the problem.

\javacode{Pro164}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 332 Reconstruct Itinerary
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 332 Reconstruct Itinerary}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a list of airline tickets represented by
     pairs of departure and arrival airports [from, to],
      reconstruct the itinerary in order.
       All of the tickets belong to a man who departs from JFK.
        Thus, the itinerary must begin with JFK.

    Note:
        If there are multiple valid itineraries,
         you should return the itinerary that has the smallest lexical order
          when read as a single string.
           For example,
            the itinerary ["JFK", "LGA"] has a smaller lexical
             order than ["JFK", "LGB"].
        All airports are represented by three capital letters (IATA code).
        You may assume all tickets form at least one valid itinerary.

    Example 1:
        tickets
             = [["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]]
        Return ["JFK", "MUC", "LHR", "SFO", "SJC"].
    Example 2:
        tickets
             = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
        Return ["JFK","ATL","JFK","SFO","ATL","SFO"].
        Another possible reconstruction is ["JFK","SFO","ATL","JFK","ATL","SFO"].
         But it is larger in lexical order.

    https://leetcode.com/problems/reconstruct-itinerary/

\end{lstlisting}

\textbf{Solution}

~~A clear DFS problem in adjacency graph. However, I truly struggled for a long while on the `smallest lexical order'. So sort them!

\javacode{Pro332}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 91 Decode Ways
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 91 Decode Ways}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    A message containing letters from A-Z is
     being encoded to numbers using the following mapping:

    'A' -> 1
    'B' -> 2
    ...
    'Z' -> 26
    Given an encoded message containing digits,
     determine the total number of ways to decode it.

    For example,
    Given encoded message "12", it could be decoded as
     "AB" (1 2) or "L" (12).

    The number of ways decoding "12" is 2.

    https://leetcode.com/problems/decode-ways/

\end{lstlisting}

\textbf{Solution}

~~dp[i] = ((last\_digit==0) ? dp[i - 1] : 0) + ((10$<=$last\_2\_digits$<=$26) ? dp[i - 2] : 0);

\javacode{Pro91}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 166 Fraction to Recurring Decimal
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 166 Fraction to Recurring Decimal}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given two integers representing the numerator and
     denominator of a fraction, return the fraction in string format.

    If the fractional part is repeating,
     enclose the repeating part in parentheses.

    For example,

        Given numerator = 1, denominator = 2, return "0.5".
        Given numerator = 2, denominator = 1, return "2".
        Given numerator = 2, denominator = 3, return "0.(6)".

    Hint:

    No scary math, just apply elementary math knowledge.
     Still remember how to perform a long division?
    Try a long division on 4/9, the repeating part is obvious.
     Now try 4/333. Do you see a pattern?
    Be wary of edge cases! List out as many test cases
     as you can think of and test your code thoroughly.

    https://leetcode.com/problems/fraction-to-recurring-decimal/

\end{lstlisting}

\textbf{Solution}

~~Use a HashMap to store existing states. Not every digit but every remainders, for example, 1/7 $->$ (1 . 3(10\%7) . 2(30\%7) . 6(20\%7) . 4(60\%7) . 5(40\%7)) . (1(50\%7) ....

\javacode{Pro166}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 301 Remove Invalid Parentheses
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 301 Remove Invalid Parentheses}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Remove the minimum number of invalid parentheses in order to
     make the input string valid. Return all possible results.

    Note: The input string may contain letters other than
     the parentheses ( and ).

    Examples:
        "()())()" -> ["()()()", "(())()"]
        "(a)())()" -> ["(a)()()", "(a())()"]
        ")(" -> [""]

    https://leetcode.com/problems/remove-invalid-parentheses/

\end{lstlisting}

\textbf{Solution - BFS}

~~The problem can be solved in both DFS \& BFS way.

~~Basic train of thought is to remove every character in string iteratively to check if generated string is valid.

~~For BFS, it is a natural idea when we want to find the minimum of invalid parentheses.

\javacode{Pro301_1}{Solution 1}

\textbf{Solution - DFS}

~~The idea is searched from Internet, copied here,

~~Key Points:

~~~~Generate unique answer once and only once, do not rely on Set.

~~~~~~Do not need preprocess.

~~~~~~Runtime 3 ms.

~~~~~~Explanation: We all know how to check a string of parentheses is valid using a stack. Or even simpler use a counter. The counter will increase when it is `(' and decrease when it is `)'. Whenever the counter is negative, we have more `)' than `(' in the prefix.

~~~~To make the prefix valid, we need to remove a `)'. The problem is: which one? The answer is any one in the prefix. However, if we remove any one, we will generate duplicate results, for example: s = ()), we can remove s[1] or s[2] but the result is the same (). Thus, we restrict ourself to remove the first ) in a series of concecutive )s.

~~~~After the removal, the prefix is then valid. We then call the function recursively to solve the rest of the string. However, we need to keep another information: the last removal position. If we do not have this position, we will generate duplicate by removing two `)' in two steps only with a different order. For this, we keep tracking the last removal position and only remove `)' after that.

~~~~Now one may ask. What about `('? What if s = `(()(()' in which we need remove `('? The answer is: do the same from right to left. However a cleverer idea is: reverse the string and reuse the code! Here is the final implement in Java.

\url{https://leetcode.com/discuss/81478/easy-short-concise-and-fast-java-dfs-3-ms-solution}

\javacode{Pro301_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 201 Bitwise AND of Numbers Range
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 201 Bitwise AND of Numbers Range}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a range [m, n] where 0 <= m <= n <= 2147483647,
     return the bitwise AND of all numbers in this range, inclusive.

    For example, given the range [5, 7], you should return 4.

    https://leetcode.com/problems/bitwise-and-of-numbers-range/

\end{lstlisting}

\textbf{Solution}

~~The problem is really interesting, it can finally be transformed to a problem to find common prefix of m and n in binary representation and fill 0 to the end to cover the position.

\javacode{Pro201_1_1}{Solution 1.1}

~~ Another solution is as below, which is in nature the same as previous method.

\javacode{Pro201_1_2}{Solution 1.2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 151 Reverse Words in a String
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 151 Reverse Words in a String}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an input string, reverse the string word by word.

    For example,
    Given s = "the sky is blue",
    return "blue is sky the".

    Update (2015-02-12):
    For C programmers: Try to solve it in-place in O(1) space.


    Clarification:
       Q: What constitutes a word?
       A: A sequence of non-space characters constitutes a word.
       Q: Could the input string contain leading or trailing spaces?
       A: Yes. However, your reversed string should not contain
             leading or trailing spaces.
       Q: How about multiple spaces between two words?
       A: Reduce them to a single space in the reversed string.

    https://leetcode.com/problems/reverse-words-in-a-string/

\end{lstlisting}

\textbf{Solution}

~~ The $O(n)$ solution(can only in C since C regards string as char array). Reverse each word, and then reverse the whole sentence.

\javacode{Pro151_1_1}{Solution 1.1}

~~ Well, in `Discuss' section, solutions make use of built-in functions, which I think is not that proper....(But really concise and short).

\javacode{Pro151_1_2}{Solution 1.2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 128 Longest Consecutive Sequence
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 128 Longest Consecutive Sequence}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an unsorted array of integers,
     find the length of the longest consecutive elements sequence.

    For example,
    Given [100, 4, 200, 1, 3, 2],
    The longest consecutive elements sequence is [1, 2, 3, 4].
     Return its length: 4.

    Your algorithm should run in O(n) complexity.

    https://leetcode.com/problems/longest-consecutive-sequence/

\end{lstlisting}

\textbf{Solution}

~~ Brute force method is to use Sorting methods to sort the array first, but with at least $O(n logn)$,

~~ For $O(n)$ solution, not so difficult, just use a Set to store all elements in the array, iterate each of them and find if there are ascending and descending elements to update the maximum consecutive length, and remove them from Set to avoid duplicate calculation.

\javacode{Pro128}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 312 Burst Balloons
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 312 Burst Balloons}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given n balloons, indexed from 0 to n-1.
     Each balloon is painted with a number on it represented by array nums.
      You are asked to burst all the balloons.
       If the you burst balloon i you will get
        nums[left] * nums[i] * nums[right] coins.
         Here left and right are adjacent indices of i.
          After the burst, the left and right then becomes adjacent.

    Find the maximum coins you can collect by bursting the balloons wisely.

    Note:
    (1) You may imagine nums[-1] = nums[n] = 1.
     They are not real therefore you can not burst them.
    (2) 0 <= n <= 500, 0 <= nums[i] <= 100

    Example:

    Given [3, 1, 5, 8]

    Return 167

        nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
       coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167

    https://leetcode.com/problems/burst-balloons/

\end{lstlisting}

\textbf{Solution}

~~A excellent DP problem.

~~The state transition equation is dp[l][r]=nums[l]*nums[m]*nums[r] + dp[l][m] + dp[m][r], l$<$m$<$r;

~~For detailed solution description, see

 \url{http://bookshadow.com/weblog/2015/11/30/leetcode-burst-balloons/}

\javacode{Pro312}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 330 Patching Array
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 330 Patching Array}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a sorted positive integer array nums and an integer n,
     add/patch elements to the array such that any number
      in range [1, n] inclusive can be formed by the sum of
       some elements in the array.
        Return the minimum number of patches required.

    Example 1:
        nums = [1, 3], n = 6
        Return 1.

        Combinations of nums are [1], [3], [1,3],
         which form possible sums of: 1, 3, 4.
        Now if we add/patch 2 to nums, the combinations are:
         [1], [2], [3], [1,3], [2,3], [1,2,3].
        Possible sums are 1, 2, 3, 4, 5, 6,
         which now covers the range [1, 6].
        So we only need 1 patch.

    Example 2:
        nums = [1, 5, 10], n = 20
        Return 2.
        The two patches can be [2, 4].

    Example 3:
        nums = [1, 2, 2], n = 5
        Return 0.

    https://leetcode.com/problems/patching-array/

\end{lstlisting}

\textbf{Solution}

~~ The idea is not so easy to figure out.

~~ First, we sort the list from smallest to largest.

~~ Then iterate the list(or iterate through 1 to required max-sum).

~~ We maintain a maximum sum we can reach currently.

~~~~When we meet nums[i] $<=$ sum, eg: [1,2,10], curSum = 0 at first. 1 $<=$ 0+1, then curSum += 1; then 2 $<=$ 1+1, curSum += 2;

~~~~When nums[i] $>$ sum, eg, curSum=4 \& nums[i]=10 in previous example, now we cannot reach sum more than curSum, we then add curSum+1 to out list to get more conditions for sum. What is the maximum sum we can reach now? The answer is curSum*2+1(2*(curSum+1) - 1).

~~~~Note that a common pitfall is that sum may exceed max int, so we use long instead of int. (Consider the test case [1,2,31,33], 2147483647)
\javacode{Pro330}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 306 Additive Number
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 306 Additive Number}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Additive number is a string whose digits can form additive sequence.

    A valid additive sequence should contain at least three numbers.
     Except for the first two numbers,
      each subsequent number in the sequence must be the sum of the preceding two.

    For example:
    "112358" is an additive number because the digits can
     form an additive sequence: 1, 1, 2, 3, 5, 8.
        1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8

    "199100199" is also an additive number, the additive sequence is:
         1, 99, 100, 199.
        1 + 99 = 100, 99 + 100 = 199

    Note: Numbers in the additive sequence cannot have leading zeros,
     so sequence 1, 2, 03 or 1, 02, 3 is invalid.

    Given a string containing only digits '0'-'9',
     write a function to determine if it's an additive number.

    Follow up:
    How would you handle overflow for very large input integers?

    https://leetcode.com/problems/additive-number/

\end{lstlisting}

\textbf{Solution}

~~Brute force, iterate to get 2 starting adjacent strings, add them until we find(or can't find) correct answer.

~~ But, except for using `long' type, this solution is not able to handle too large integer.(Or maybe BigInteger or applying addition on long number sequence?)

\javacode{Pro306}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 56 Merge Intervals
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 56 Merge Intervals}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a collection of intervals,
     merge all overlapping intervals.

    For example,
        Given [1,3],[2,6],[8,10],[15,18],
        return [1,6],[8,10],[15,18].

    https://leetcode.com/problems/merge-intervals/

\end{lstlisting}

\textbf{Solution}

~~Sort all intervals according to their start number(write a new Comparator). Then there are 3(or 2, to be more specific) conditions, eg, [1,100] VS [90,101] or [90,99] with [1,10] VS [90,100].

~~ For those cur.end $>=$ next.start, combine the 2 intervals, set cur.end = Math.max(next.end, cur.end); for opposite conditions, set cur = new Node(next.start, next.end);

\javacode{Pro56}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 57 Insert Interval
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 57 Insert Interval}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a set of non-overlapping intervals,
     insert a new interval into the intervals (merge if necessary).

    You may assume that the intervals were initially sorted
     according to their start times.

    Example 1:
    Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].

    Example 2:
    Given [1,2],[3,5],[6,7],[8,10],[12,16],
     insert and merge [4,9] in as [1,2],[3,10],[12,16].

    This is because the new interval [4,9]
     overlaps with [3,5],[6,7],[8,10].

    https://leetcode.com/problems/insert-interval/

\end{lstlisting}

\textbf{Solution}

~~Iterate every element in former List. Three conditions are waiting:

~~\begin{enumerate}
    \item cur.end $<$ new.start, add to list, continue
    \item cur.start $>$ new.end, break, this is where we should insert our new Interval(maybe not the initial one)
    \item cur interleaves with new, set new.start = min{cur.start, new.start}, new.end = max{cur.end, new.end}, continue;
\end{enumerate}

~~~Finally don't forget to add \textbf{new} and those Intervals after \textbf{new}(cur.start $>$ new.end) to end of result list.

~~~(BTW, there is another solution, first use binary search to decide where to insert the new Interval, then use the same idea in Problem ``Merge Intervals'', to re-merge the list.)

\javacode{Pro57}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 87 Scramble String
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 87 Scramble String}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a string s1, we may represent it as
     a binary tree by partitioning it to two non-empty substrings recursively.

    Below is one possible representation of s1 = "great":

        great
       /    \
      gr    eat
     / \    /  \
    g   r  e   at
               / \
              a   t
    To scramble the string, we may choose any non-leaf node and
     swap its two children.

    For example, if we choose the node "gr" and swap its two children,
     it produces a scrambled string "rgeat".

        rgeat
       /    \
      rg    eat
     / \    /  \
    r   g  e   at
               / \
              a   t
    We say that "rgeat" is a scrambled string of "great".

    Similarly, if we continue to swap the children of nodes
     "eat" and "at", it produces a scrambled string "rgtae".

        rgtae
       /    \
      rg    tae
     / \    /  \
    r   g  ta  e
           / \
          t   a
    We say that "rgtae" is a scrambled string of "great".

    Given two strings s1 and s2 of the same length,
     determine if s2 is a scrambled string of s1.

    https://leetcode.com/problems/scramble-string/

\end{lstlisting}

\textbf{Solution - Recursion}

~~First the recursive solution. Still use an example to help understanding.

~~For s1 = `great' and s2 = `rgtae'. We split each string to 2 parts, the split point can be every letter in word. When we split s1 to `gr' and `eat', while s2 to `rg' and `tae'(along with `ae' and `rgt'), the scramble can only be possible to take place between `gr' and `rg'(or maybe `ae', recurse along this idea until the 2 words equal ,length not equals, or letters they contain are not the same(aab and bab/c, etc). If we don't use the last condition to prune, we will get TLE(using bit operation neither, see comments in code).

\javacode{Pro87_1}{Solution 1}

\textbf{Solution - DP}

~~Second solution makes use of Dynamic Programming, with the state transition equation:

~~~~The idea is search from the Internet. For dp[k][i][j], it means whether s1[i to i+k-1] equals to s2[j to j+k-1]

~~ See \url{http://www.acmerblog.com/leetcode-solution-scramble-string-6224.html}

\javacode{Pro87_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 315 Count of Smaller Numbers After Self
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 315 Count of Smaller Numbers After Self}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    You are given an integer array nums and you have to return
     a new counts array.
      The counts array has the property where counts[i]
       is the number of smaller elements to the right of nums[i].

    Example:

        Given nums = [5, 2, 6, 1]

        To the right of 5 there are 2 smaller elements (2 and 1).
        To the right of 2 there is only 1 smaller element (1).
        To the right of 6 there is 1 smaller element (1).
        To the right of 1 there is 0 smaller element.
        Return the array [2, 1, 1, 0].

    https://leetcode.com/problems/count-of-smaller-numbers-after-self/

\end{lstlisting}

\textbf{Solution - Merge Sort}

~~Merge sort is a typical solution on finding inversions. On Book ``Offer'', there is a similar problem of finding all inversions in an array which uses merge sort too.

~~An Example, For [2,4],[1,3], we first compare 4 \& 3, when 4 is bigger, smaller count of 4 is 2(1 and 3, index(3) - index(1) + 1), similarly, smaller count of 2 is 1...

\javacode{Pro315_1}{Solution 1}

\textbf{Solution - BIT}

~~ For BIT, we firstly sort and discrete the original array to make array in BIT much shorter. Then we assign each element a index according to its position after sorted, eg: for [5,2,6,1], there will be $1\ ->\ 1, 2\ ->\ 2, 3\ ->\ 5, 4\ ->\ 6$.

~~ Then it's time for BIT to take effect. We iterate from tail of original array, now sum of discrete[nums[i]] is count of its smaller elements, and we may then update the BIT since we have a new element counting from right.

~~ Since we are counting `smaller' rather than `not bigger', we have to minus 1 to discrete[num[i]] when doing the sum operation, which is a bit forgettable.

\javacode{Pro315_2}{Solution 2}

~~ There is also a BST solution in \\
\url{http://whatsme.net/2015/12/16/Count-of-Smaller-Numbers-After-Self/}

~~Segment tree:\\
 \url{https://leetcode.com/discuss/73917/accepted-c-solution-using-segment-tree}

~~Divide and Conquer: \\
\url{https://leetcode.com/discuss/73326/divide-and-conquer-like-merge-sort-order-statistics-tree}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 327 Count of Range Sum
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 327 Count of Range Sum}}

\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

   Given an integer array nums,
    return the number of range sums that lie in [lower, upper] inclusive.
    Range sum S(i, j) is defined as
     the sum of the elements in nums between indices i and j (i <= j), inclusive.

    Note:
    A naive algorithm of O(n2) is trivial.
     You MUST do better than that.

    Example:
        Given nums = [-2, 5, -1], lower = -2, upper = 2,
        Return 3.
        The three ranges are : [0, 0], [2, 2], [0, 2]
         and their respective sums are: -2, -1, 2.

    https://leetcode.com/problems/count-of-range-sum/

\end{lstlisting}

\textbf{Solution - Merge Sort}

~~The Merge sort train of thought is a bit like Problem ``Count of Smaller Numbers After Self''. We first sum up [0,x] elements to get a sums array with the length of n(which means, to be more specific, sums[0] = nums[0], sums[1] = nums[0] + nums[1], ...., sums[n] = nums[0] + nums[1] + nums[2] + ...).

~~ Then apply Merge Sort among sums array. During merging, count the sums satisfy the [lower, upper] constraint. How?

~~ Let's see what we are looking for. What is the value of sum from index i to j? sums[i to j] = sums[j] - sums[i - 1]. So what we do is to check every possible index pair (i,j) to check if sums[i to j] satisfy the constraint.

~~ So why Merge Sort?(Honestly, because of its $O(log n) runtime$ complexity.) And how? Let example talk.

~~ Suppose we are doing merge sort at a circumstance where the sums array looks like [(2,5,9),(6,8,11)] with upper=7 and lower=5, then we may combine the array to [2,5,6,8,9,11]... Wait! We have something else to do. When checking 2, we should also check 6,8 and maybe 11. See 6-2=4 $<$ 5, continue when 8-2=6 $>$ 5, stop and mark lowerIdx=idx(8), then 11-2 $>$ 7, mark upperIdx=idx(11), then we add count 1 to totalCnt.

~~Namely, the merge sort based solution counts the answer while doing the merge. During the merge stage, we have already sorted the left half [start, mid) and right half [mid, end). We then iterate through the left half with index i. For each i, we need to find two indices k and j in the right half where

~~~~j is the first index satisfy sums[j] - sums[i] $>$ upper and\\
~~~~k is the first index satisfy sums[k] - sums[i] $>=$ lower.

~~~~Then the number of sums in [lower, upper] is j-k. We also use another index t to copy the elements satisfy sums[t] $<$ sums[i] to a cache in order to complete the merge sort.

~~ Finally, don't forget to use long type since the last test data will be out of bound.

\javacode{Pro214_1}{Solution 1}

\textbf{Solution - BST}

~~I didn't understand the solution at first sight, but honestly this is more intuitive. We are looking for a range sum from `lower' to `upper', so when we consider the `sums' array in previous solution, we are looking for a $lower <= sums[j] - sums[i-1] <= upper$. So we build a BST to store each sums, before inserting a new sums[i], we check in the tree that is there any previous sums X which satisfy $X >= sums[j] - upper$ and $X <= sums[j] - lower$. We used an exclusive method to get final result.

\javacode{Pro214_2}{Solution 2}

\textbf{Solution - Others(BIT)}

~~ Honestly, I don't quite understand the insight of this solution, just paste here the code searched from Discuss part for further usage.

\javacode{Pro214_3}{Solution 3}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 30 Substring with Concatenation of All Words
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 30 Substring with Concatenation of All Words}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

   You are given a string, `s', and a list of words, `words',
    that are all of the same length.
     Find all starting indices of substring(s) in s
      that is a concatenation of each word in words exactly once
       and without any intervening characters.

    For example, given:
        s: "barfoothefoobarman"
        words: ["foo", "bar"]

    You should return the indices: [0,9].
    (order does not matter).

    https://leetcode.com/problems/substring-with-concatenation-of-all-words/

\end{lstlisting}

\textbf{Solution}

~~Just a Brute force method, the condition that all words are of the same length makes the problem much easier. Keep a given length of sequence and check every word in it if they match our given \textbf{words} array.

\javacode{Pro30}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 149 Max Points on a Line
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 149 Max Points on a Line}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

   Given n points on a 2D plane,
    find the maximum number of points that lie on the same straight line.

    https://leetcode.com/problems/max-points-on-a-line/

\end{lstlisting}

\textbf{Solution}

~~Main idea is to use the slope to form a map to check the number of points on same line. Iterate both i and j from 0 to n(which I think has lots of duplicate calculation).

~~Other difficulties are caused by corner cases: points with same x; same points; when all points are in the same position...

\javacode{Pro149}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 115 Distinct Subsequences
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 115 Distinct Subsequences}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

   Given a string S and a string T,
    count the number of distinct subsequences of T in S.

    A subsequence of a string is a new string
     which is formed from the original string by deleting some
      (can be none) of the characters without disturbing
       the relative positions of the remaining characters.
        (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is not).

    Here is an example:
        S = "rabbbit", T = "rabbit"

        Return 3.

    https://leetcode.com/problems/distinct-subsequences/

\end{lstlisting}

\textbf{Solution}

~~ Honestly, this is not a difficult DP problem. The state transition equation is simple:

~~ Let dp[i][j] represents match count of first ith letters in S with first jth letters in T.

~~~When s.charAt(i-1) == t.charAt(j-1), then dp[i][j] = dp[i-1][j-1] + dp[i-1][j]; Eg, for 2nd a in rrraa(t is ra), dp equals 3 + 3, where first 3 represents how many `ra' the first `rrra' can produce; where last 3 represents how many can `rrrXa(current a)' get.

~~~While when s.charAt(i-1) != t.charAt(j-1), dp[i][j] = dp[i - 1][j];

\javacode{Pro115}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 97 Interleaving String
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 97 Interleaving String}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

   Given s1, s2, s3, find whether s3 is formed
    by the interleaving of s1 and s2.

    For example,
    Given:
    s1 = "aabcc",
    s2 = "dbbca",

    When s3 = "aadbbcbcac", return true.
    When s3 = "aadbbbaccc", return false.

    https://leetcode.com/problems/interleaving-string/

\end{lstlisting}

\textbf{Solution}

~~Another DP problem involving String issues.

~~ How to find the state transition equation is a bit difficult but the equation is not difficult to understand. Though there are 3 strings, s1, s2 and s3, len(s1) + len(s2) = len(s3)(otherwise the function must return false), consequently there are only 2 independent variables, so we let boolean dp[i][j] represents if first i digits of s1 interleaved with first j digits of s2 comes up with first i+j digits of s3.

~~ Thus, dp[i][j] = (s1.charAt(i-1) == s3.charAt(i+j-1) \&\& dp[i-1][j]) $\vert\vert$ (s2.charAt(j-1) == s3.charAt(i+j-1) \&\& dp[i][j-1]);

\javacode{Pro97}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 335 Self Crossing
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 335 Self Crossing}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

   You are given an array x of n positive numbers.
    You start at point (0,0) and moves x[0] metres to the north,
     then x[1] metres to the west, x[2] metres to the south,
      x[3] metres to the east and so on.
       In other words,
        after each move your direction changes counter-clockwise.

    Write a one-pass algorithm with O(1) extra space to determine,
     if your path crosses itself, or not.

    Example 1:
        Given x = [2, 1, 1, 2],
         ---
        |   |
         ---+-->
            |

        Return true (self crossing)

    Example 2:
        Given x = [1, 2, 3, 4],
         ------
        |      |
        |
        |
         ----------->$

        Return false (not self crossing)

    Example 3:
        Given x = [1, 1, 1, 1],
         ---
        |   |
         ---+->
            |

        Return true (self crossing)

    https://leetcode.com/problems/self-crossing/

\end{lstlisting}

\textbf{Solution}

~~Well, it is more like a math problem or pattern-finding problem.

~~ The key is to find out what are the serial numbers of lines that can form a cross with the 1st line(1st line is just a representation of all lines since the process of validation can be cyclic, which means we can regard 2nd line as the \textbf{`1st'} line).

~~Just list the conclusion,

~~ there are 3 situation where 2 lines form a cross with each other,

\begin{lstlisting}[language=tex,stepnumber=100, frame=none]

        1.
                 x(1)
                 ---
            x(2)|   |x(0)
                 ---+-->
                x(3)|

        2.
                  x(1)
                 ------
                |      |x(0)
            x(2)|      ^
                |      |x(4)
                 ------|
                  x(3)

        3.
                  x(1)
                 ------
                |      |x(0)
            x(2)|     <|---|
                |      x(5)|x(4)
                -----------
                    x(3)

\end{lstlisting}

~~ Where each conditions can be derived by given circumstances. See code in listing.


\javacode{Pro335}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 68 Text Justification
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 68 Text Justification}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

   Given an array of words and a length L,
    format the text such that each line has
     exactly L characters and is fully (left and right) justified.

    You should pack your words in a greedy approach;
     that is, pack as many words as you can in each line.
      Pad extra spaces ' ' when necessary so that each line
       has exactly L characters.

    Extra spaces between words should be distributed
     as evenly as possible.
      If the number of spaces on a line do not divide evenly between words,
       the empty slots on the left will be assigned more spaces
        than the slots on the right.

    For the last line of text, it should be left justified and
     no extra space is inserted between words.

    For example,
        words: ["This", "is", "an", "example", "of", "text", "justification."]
        L: 16.

        Return the formatted lines as:
        [
           "This    is    an",
           "example  of text",
           "justification.  "
        ]
    Note: Each word is guaranteed not to exceed L in length.


    Corner Cases:
    A line other than the last line might contain only one word.
     What should you do in this case?
    In this case, that line should be left-justified.

    https://leetcode.com/problems/text-justification/

\end{lstlisting}

\textbf{Solution}

~~Just a simulation problem, but a bit complicated. Be aware of the last line and number of spaces in each line(I used Math.ceil to get spaceCnt each time, then remove spaceCnt from total space count).

\javacode{Pro68}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 218 The Skyline Problem
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 218 The Skyline Problem}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

   A city's skyline is the outer contour of the silhouette
    formed by all the buildings in that city when viewed from a distance.
     Now suppose you are given the locations and height of
      all the buildings as shown on a cityscape photo (Figure A),
       write a program to output the skyline
        formed by these buildings collectively (Figure B).

     Buildings  Skyline Contour
    The geometric information of each building
     is represented by a triplet of integers [Li, Ri, Hi],
      where Li and Ri are the x coordinates of
       the left and right edge of the ith building, respectively,
        and Hi is its height.
         It is guaranteed that 0 <= Li, Ri <= INT_MAX,
          0 < Hi <= INT_MAX, and Ri - Li > 0.
           You may assume all buildings are perfect rectangles
            grounded on an absolutely flat surface at height 0.

    For instance, the dimensions of all buildings in Figure A
     are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .

    The output is a list of "key points" (red dots in Figure B)
     in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ]
      that uniquely defines a skyline.
       A key point is the left endpoint of a horizontal line segment.
        Note that the last key point, where the rightmost building ends,
         is merely used to mark the termination of the skyline,
          and always has zero height.
           Also, the ground in between any two adjacent buildings
            should be considered part of the skyline contour.

    For instance, the skyline in Figure B should be
     represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ].

    Notes:

        The number of buildings in any input list is guaranteed
             to be in the range [0, 10000].
        The input list is already sorted in
             ascending order by the left x position Li.
        The output list must be sorted by the x position.
        There must be no consecutive horizontal lines of
            equal height in the output skyline.
             For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...]
              is not acceptable;
               the three lines of height 5 should be
                merged into one in the final output as such:
                 [...[2 3], [4 5], [12 7], ...]

    https://leetcode.com/problems/the-skyline-problem/

\end{lstlisting}

\includegraphics[width=0.5\columnwidth]{figures/218_the_skyline_problem_1}
\includegraphics[width=0.5\columnwidth]{figures/218_the_skyline_problem_2}

\textbf{Solution}

~~Not so difficult if we know the routine to solve this problem.

~~1. We use left top and right top corner of rectangle to represent itself, for simplicity.

~~2. Sort the Points(corners) according to x-axis value, from small to large ones, identifying the left corner and right corner.

~~3. Iterate each Point, when we meet a left corner, add it into a max heap by its y-axis value. When the value we add is larger than former peek from heap, we may find a new `shadow', so we add the (x,y) pair into result; when there is a right corner, pop it from the heap. When new peek is smaller than the element we pop, this is a new identifying point, add it into result.

~~4. Don't forget to deal with some corner cases, imagine when input is [[1,2,1],[2,3,1]] OR [[1,2,1],[1,2,2],[1,2,3]] OR [[1,2,2],[1,2,3],[1,2,1]], what will happen?

\javacode{Pro218}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 336 Palindrome Pairs
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 336 Palindrome Pairs}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

   Given a list of unique words.
    Find all pairs of distinct indices (i, j) in the given list,
     so that the concatenation of the two words,
      i.e. words[i] + words[j] is a palindrome.

    Example 1:
        Given words = ["bat", "tab", "cat"]
        Return [[0, 1], [1, 0]]
        The palindromes are ["battab", "tabbat"]
    Example 2:
        Given words = ["abcd", "dcba", "lls", "s", "sssll"]
        Return [[0, 1], [1, 0], [3, 2], [2, 4]]
        The palindromes are ["dcbaabcd", "abcddcba", "slls", "llssssll"]

    https://leetcode.com/problems/palindrome-pairs/

\end{lstlisting}

\textbf{Solution}

~~First of all I must state that I don't think the problem is correct. When my input is ["aaa", "aaa", "aaa","aa","aa"] I should have gotten all combinations as my answer, but the expected answer is not what I want.

~~In order to pass the judgement, I have to do it in the way OJ advises.

~~When si+sj is palindrome, for example ``as'' and ``llsa'', there must be `ll' be a palindrome and `as' be reversed by `sa'. That's our key insight of solution. Iterate every word, split it into 2 parts, left and right, check if left OR right is palindrome and if it does, reverse the remaining part to see if it matches any other strings in original list.

\javacode{Pro336}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 146 LRU Cache
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 146 LRU Cache}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

   Design and implement a data structure for Least Recently Used (LRU) cache.
    It should support the following operations: get and set.

    get(key) - Get the value (will always be positive)
         of the key if the key exists in the cache, otherwise return -1.
    set(key, value) - Set or insert the value
        if the key is not already present.
         When the cache reached its capacity,
          it should invalidate the least recently used item
           before inserting a new item.

    https://leetcode.com/problems/lru-cache/

\end{lstlisting}

\textbf{Solution}

~~A interesting and not so difficult problem. With plenty kinds of solutions. The most convenient method I've ever seen is to extend LinkedHashMap directly and overwrite some functions, which I think is a bit tricky.

~~Use a HashMap to trace each element in cache and out of cache. For each CacheEntry, assign its previous entry and next entry. A trick is to assign initially a dummy head and dummy tail node to quickly acquire the least recently used entry(by tail.prev) and most recently used(by head.next).

\javacode{Pro146}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 214 Shortest Palindrome
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 214 Shortest Palindrome}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

   Given a string S, you are allowed to convert it to a palindrome
    by adding characters in front of it.
     Find and return the shortest palindrome you can find by
      performing this transformation.

    For example:

    Given "aacecaaa", return "aaacecaaa".

    Given "abcd", return "dcbabcd".

    https://leetcode.com/problems/shortest-palindrome/

\end{lstlisting}

\textbf{Solution}

~~A Brute force method is to substring from (0, s.length()) to (0,1), if the substring result is palindrome, then stop checking immediately(to get the shortest result) and reverse the remaining string when palindrome is cut from original string. Then attach the reversed string to the head of original string, which is exactly our result. Worst complexity $O(n^2)$, which will get TLE.

~\\

~~Another train of thought is to use the KMP algorithm.

~~ For a quicker review of KMP, visit \url{http://www.cnblogs.com/c-cloud/p/3224788.html}.

~~ For Chinese description of this problem, visit \url{https://segmentfault.com/a/1190000003059361}

~~ Actually, the next[] array is enough for this problem. First we append reversed source string to tail of original string to get quite a long string for a result. Apply KMP on new string, get the largest element in next array, which is exactly the reversed part of original string.

~~BUT! We are extending the next array to be twice length as what former string has, which may lead to a error state that our longest prefix \& suffix go through both reversed string and original string, when we only want to find longest prefix/suffix in original string. So we add a special character between s and reverse\_s(here we use `\#').

~~ In conclusion, our solution can be divided into 3 steps.

\begin{enumerate}
    \item Reverse string s as rev\_s
    \item Append rev\_s to tail of s, namely form s\#{rev\_s}
    \item Apply KMP to new string, get the maximum common length of prefix and suffix, such segment of string is actually palindrome(think of why.)
    \item Split rev\_s to get s.length() - common\_length substring, attach it to head of string s
\end{enumerate}

\javacode{Pro214}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 321 Create Maximum Number
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 321 Create Maximum Number}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

   Given two arrays of length m and n with digits 0-9 representing two numbers.
    Create the maximum number of length k $<=$ m + n
     from digits of the two. The relative order of the digits
      from the same array must be preserved.
       Return an array of the k digits.
        You should try to optimize your time and space complexity.

    Example 1:
        nums1 = [3, 4, 6, 5]
        nums2 = [9, 1, 2, 5, 8, 3]
        k = 5
        return [9, 8, 6, 5, 3]

    Example 2:
        nums1 = [6, 7]
        nums2 = [6, 0, 4]
        k = 5
        return [6, 7, 6, 0, 4]

    Example 3:
        nums1 = [3, 9]
        nums2 = [8, 9]
        k = 3
        return [9, 8, 9]

    https://leetcode.com/problems/create-maximum-number/

\end{lstlisting}

\textbf{Solution}

~~A Greedy problem, paste the solution in Chinese down here since I may not explain it correctly and accurately.

\includegraphics[width=0.6\columnwidth]{figures/321_create_maximum_number}

\javacode{Pro321}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 343 Integer Break
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 343 Integer Break}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

   Given a positive integer n,
    break it into the sum of at least two positive integers
     and maximize the product of those integers.
      Return the maximum product you can get.

    For example, given n = 2,
     return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).

    Note: you may assume that n is not less than 2.

    Hint:

    There is a simple O(n) solution to this problem.
    You may check the breaking results of n ranging from
     7 to 10 to discover the regularities.

    https://leetcode.com/problems/integer-break/

\end{lstlisting}

\textbf{Solution}

~~ Take as many 3 as we can, the proof process can be found below.

~~ However, I'm not using such train of thought, but iterate each possible count of sum to get maximum product.

\includegraphics[width=1\columnwidth]{figures/343_integer_break}

\javacode{Pro343}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 344 Reverse String
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 344 Reverse String}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

   Write a function that takes a string as input and returns the string reversed.

    Example:
    Given s = "hello", return "olleh".

    https://leetcode.com/problems/reverse-string/

\end{lstlisting}

\textbf{Solution}

~~ An easy problem with plenty of ways to solve it.

\javacode{Pro344}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 345 Reverse Vowels of a String
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 345 Reverse Vowels of a String}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

   Write a function that takes a string as input and
    reverse only the vowels of a string.

    Example 1:
    Given s = "hello", return "holle".

    Example 2:
    Given s = "leetcode", return "leotcede".

    https://leetcode.com/problems/reverse-vowels-of-a-string/

\end{lstlisting}

\textbf{Solution}

~~ An easy problem either, a bit bit more difficult than previous problem `Reverse String'.

\javacode{Pro345}{Solution}

\end{homeworkProblem}
\newpage


%----------------------------------------------------------------------------------------
%	PROBLEM 349 Intersection of Two Arrays
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 349 Intersection of Two Arrays}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

   Given two arrays, write a function to compute their intersection.

    Example:
    Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].

    Note:
    Each element in the result must be unique.
    The result can be in any order.

    https://leetcode.com/problems/intersection-of-two-arrays/

\end{lstlisting}

\textbf{Solution}

~~ Using HashSet to find intersection and avoid duplicate.

\javacode{Pro349}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 350 Intersection of Two Arrays II
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 350 Intersection of Two Arrays II}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

   Given two arrays, write a function to compute their intersection.

    Example:
    Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].

    Note:
    Each element in the result should appear as many times as it shows in both arrays.
    The result can be in any order.
    Follow up:
    What if the given array is already sorted? How would you optimize your algorithm?
    What if nums1's size is small compared to nums2's size? Which algorithm is better?
    What if elements of nums2 are stored on disk, and the memory is limited
     such that you cannot load all elements into the memory at once?

    https://leetcode.com/problems/intersection-of-two-arrays-ii/

\end{lstlisting}

\textbf{Solution 1}

~~ The most direct solution is to use a HashMap for 1 array recording each number for occurrence and match another, maintaining the count of number in 2nd array.

\javacode{Pro350_1}{Solution 1}

\textbf{Solution 2}

~~Another train of thought is by sorting and merging, can be achieved using either Arrays.sort or manually quickSort.

\javacode{Pro350_2}{Solution 2}

~~However, I still feel that we need further investigation on that, on one hand we are not quite sure about the questions in Follow up, while on the other there is no difference between I and II on algorithm, which may indicates that there must be somewhere we can optimize.

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 371 Sum of Two Integers
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 371 Sum of Two Integers}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

   Calculate the sum of two integers a and b, but you are
    not allowed to use the operator + and -.

    Example:
    Given a = 1 and b = 2, return 3.

    https://leetcode.com/problems/sum-of-two-integers/

\end{lstlisting}

\textbf{Solution}

~~ It's more a mathematical(bit manipulation) problem. For a + b, if there is no carry, the result is exactly a xor b by bit; similarly, if no carry, the new carry is (a \& b) $<<$ 1, adding them still get sum, which begins a new iteration. Loop until new carry == 0, where a xor b gets final sum.

\javacode{Pro371}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 383 Ransom Note
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 383 Ransom Note}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

   Given an arbitrary ransom note string and another string containing letters
    from all the magazines, write a function that will return true if the ransom note
     can be constructed from the magazines ; otherwise, it will return false.

    Each letter in the magazine string can only be used once in your ransom note.

    Note:
    You may assume that both strings contain only lowercase letters.

    canConstruct("a", "b") - false
    canConstruct("aa", "ab") - false
    canConstruct("aa", "aab") - true

    https://leetcode.com/problems/ransom-note/

\end{lstlisting}

\textbf{Solution}

~~ Array is enough.

\javacode{Pro383}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 373 Find K Pairs with Smallest Sums
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 373 Find K Pairs with Smallest Sums}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    You are given two integer arrays nums1 and nums2 sorted in ascending order
     and an integer k.

    Define a pair (u,v) which consists of one element from the first array
     and one element from the second array.

    Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.

    Example 1:
    Given nums1 = [1,7,11], nums2 = [2,4,6],  k = 3

    Return: [1,2],[1,4],[1,6]

    The first 3 pairs are returned from the sequence:
    [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
    Example 2:
    Given nums1 = [1,1,2], nums2 = [1,2,3],  k = 2

    Return: [1,1],[1,1]

    The first 2 pairs are returned from the sequence:
    [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]
    Example 3:
    Given nums1 = [1,2], nums2 = [3],  k = 3

    Return: [1,3],[2,3]

    All possible pairs are returned from the sequence:
    [1,3],[2,3]

    https://leetcode.com/problems/find-k-pairs-with-smallest-sums/

\end{lstlisting}

\textbf{Solution}

~~ Heap is the key to solution. However, this is not adequate, the train of thought is still a bit complicated.

~~ See explanation and figure from Discussion section.

~~Basic idea: Use min\_heap to keep track on next minimum pair sum, and we only need to maintain K possible candidates in the data structure.

~~ Some observations: For every numbers in nums1, its best partner(yields min sum) always strats from nums2[0] since arrays are all sorted; And for a specific number in nums1, its next candidate sould be [this specific number] + nums2[current\_associated\_index + 1], unless out of boundary;)

~~Here is a simple example demonstrate how this algorithm works.

\includegraphics[width=1\columnwidth]{figures/373_find_k_pairs_with_smallest_sums}

~~The run time complexity is O(kLogk) since que.size $<=$ k and we do at most k loop.

\javacode{Pro373}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 378 Kth Smallest Element in a Sorted Matrix
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 378 Kth Smallest Element in a Sorted Matrix}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a n * n matrix where each of the rows and columns
     are sorted in ascending order,
     find the kth smallest element in the matrix.
    Note that it is the kth smallest element in the sorted order,
     not the kth distinct element.
    Example:
    matrix = [
       [ 1,  5,  9],
       [10, 11, 13],
       [12, 13, 15]
    ],
    k = 8,

    return 13.

    Note:
    You may assume k is always valid, 1 <= k <= n2.

    https://leetcode.com/problems/find-k-pairs-with-smallest-sums/

\end{lstlisting}

\textbf{Solution}

~~ It's quite similar to Problem 373 `Find K Pairs with Smallest Sums', even easier(How I wish I can add a `wiggle' emoji here).

~~ Put elements from 1st row(column), along with their value, rowIdx and colIdx. Poll elements from PriorityQueue which is definitely the smallest by now, then add in-bound elements from the next column(row) into PriorityQueue.

\javacode{Pro378}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 374 Guess Number Higher or Lower
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 374 Guess Number Higher or Lower}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

   We are playing the Guess Game. The game is as follows:

    I pick a number from 1 to n. You have to guess which number I picked.

    Every time you guess wrong, I'll tell you whether the number is higher or lower.

    You call a pre-defined API guess(int num) which returns 3 possible results
     (-1, 1, or 0):

    -1 : My number is lower
     1 : My number is higher
     0 : Congrats! You got it!
    Example:
    n = 10, I pick 6.

    Return 6.

    https://leetcode.com/problems/guess-number-higher-or-lower/

\end{lstlisting}

\textbf{Solution}

~~ A standard binary search problem. Easy to implement and solved.

\javacode{Pro374}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 357 Count Numbers with Unique Digits
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 357 Count Numbers with Unique Digits}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

   Given a non-negative integer n, count all numbers with unique digits, x,
    where 0 $<=$ x < 10n.

    Example:
    Given n = 2, return 91. (The answer should be the total numbers
     in the range of 0 $<=$ x < 100,
     excluding [11,22,33,44,55,66,77,88,99])

    Hint:

    A direct way is to use the backtracking approach.
    Backtracking should contains three states which are
     (the current number, number of steps to get that number and a bitmask
      which represent which number is marked as visited so far in the current number).
       Start with state (0,0,0) and count all valid number
        till we reach number of steps equals to 10n.
    This problem can also be solved using a dynamic programming approach and
     some knowledge of combinatorics.
    Let f(k) = count of numbers with unique digits with length equals k.
    f(1) = 10, ..., f(k) = 9 * 9 * 8 * ... (9 - k + 2)
     [The first factor is 9 because a number cannot start with 0].

    https://leetcode.com/problems/count-numbers-with-unique-digits/

\end{lstlisting}

\textbf{Solution 1}

~~ Backtracking solution, recurse on each digit from 0 to 9, use a int act as bitmap to see which number has been used. Be careful when checking if 0 used. I'm using the method that when used == 0, other numbers have not been used, which also means that 0 chosen is the 1st digit, only in this case shouldn't we mark number 0 as used.

\javacode{Pro357_1}{Solution 1 - Backtracking}

\textbf{Solution 2}

~~ Use math method as hint says.
~~ For n = 1, f(1) = 10         [0,1,2,...,9]
~~ For n = 2, f(2) = 9 * 9      [1st-digit: 1-9 \& 2nd-digit: 0-9 except for 1st-digit]
~~ ...
~~ Finally, sum them up.

\javacode{pro357_2}{Solution 2 - Math}


\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 367 Valid Perfect Square
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 367 Valid Perfect Square}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

   Given a positive integer num, write a function which returns True
    if num is a perfect square else False.

    Note: Do not use any built-in library function such as sqrt.

    Example 1:

    Input: 16
    Returns: True
    Example 2:

    Input: 14
    Returns: False

    https://leetcode.com/problems/valid-perfect-square/

\end{lstlisting}

\textbf{Solution 1}

~~ As for a binary search problem, I can't tell this should be classified as Medium difficulty. Using division instead of multiplication is a trick to prevent overflow.

\javacode{Pro367_1}{Solution 1 - Binary Search}

\textbf{Solution 2}

~~ A interesting thing is that:

~~~~1 = 1
~~~~4 = 1 + 3
~~~~9 = 1 + 3 + 5
~~~~....

\javacode{pro367_2}{Solution 2 - Math.sum}

\textbf{Solution 3}

~~ The 3rd solution is a math method. I don't quite get the point so just leave the solution here.

\ccode{pro367_3}{Solution 3 - Math.Newton}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 376 Wiggle Subsequence
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 376 Wiggle Subsequence}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    A sequence of numbers is called a wiggle sequence if the differences between
     successive numbers strictly alternate between positive and negative.
      The first difference (if one exists) may be either positive or negative.
       A sequence with fewer than two elements is trivially a wiggle sequence.

    For example, [1,7,4,9,2,5] is a wiggle sequence because
     the differences (6,-3,5,-7,3) are alternately positive and negative.
      In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences,
       the first because its first two differences are positive and
        the second because its last difference is zero.

    Given a sequence of integers, return the length of the longest subsequence that is
     a wiggle sequence. A subsequence is obtained by deleting some number of elements
      (eventually, also zero) from the original sequence,
       leaving the remaining elements in their original order.

    Examples:
    Input: [1,7,4,9,2,5]
    Output: 6
    The entire sequence is a wiggle sequence.

    Input: [1,17,5,10,13,15,10,5,16,8]
    Output: 7
    There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].

    Input: [1,2,3,4,5,6,7,8,9]
    Output: 2
    Follow up:
    Can you do it in O(n) time?

    https://leetcode.com/problems/valid-perfect-square/

\end{lstlisting}

\textbf{Solution 1}

~~ A dp solution with $O(n^2)$, unfortunately this is the worst solution in time complexity.

\javacode{Pro376_1}{Solution 1 - DP}

\textbf{Solution 2}

~~ A $O(n)$ solution can be found in Greedy or Math. As for greedy, just find ; while as for math, just find the switching points, that is exactly the number of maxLength.

\javacode{pro376_2_1}{Solution 2 - Greedy}
\javacode{pro376_2_2}{Solution 2 - Math}



\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 387 First Unique Character in a String
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 387 First Unique Character in a String}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a string, find the first non-repeating character in it and return it's index.
     If it doesn't exist, return -1.

    Examples:

    s = "leetcode"
    return 0.

    s = "loveleetcode",
    return 2.
    Note: You may assume the string contain only lowercase letters.

    https://leetcode.com/problems/first-unique-character-in-a-string/

\end{lstlisting}

\textbf{Solution}

~~ A simple problem, array counting its count and index is enough.

\javacode{Pro387}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 365 Water and Jug Problem
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 365 Water and Jug Problem}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    You are given two jugs with capacities x and y litres.
     There is an infinite amount of water supply available.
      You need to determine whether it is possible to measure
       exactly z litres using these two jugs.

    If z liters of water is measurable,
     you must have z liters of water contained within one or both buckets
      by the end.

    Operations allowed:

    Fill any of the jugs completely with water.
    Empty any of the jugs.
    Pour water from one jug into another till the other jug is
     completely full or the first jug itself is empty.
    Example 1: (From the famous "Die Hard" example)

    Input: x = 3, y = 5, z = 4
    Output: True
    Example 2:

    Input: x = 2, y = 6, z = 5
    Output: False

    https://leetcode.com/problems/water-and-jug-problem/

\end{lstlisting}

\textbf{Solution}

~~ If you know the solution, the problem is not so difficult. Just check if z is divisible by gcd(x,y).

~~ BUT! Mention so may edge cases, like x == 0, y == 0, z == 0, and x + y $<$ z(For example, for 1,2,5, though 1+2+2=5, it cannot be achieved)

\javacode{Pro365}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 372 Super Pow
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 372 Super Pow}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Your task is to calculate ab mod 1337 where a is a positive integer
     and b is an extremely large positive integer given in the form of an array.

    Example1:

    a = 2
    b = [3]

    Result: 8
    Example2:

    a = 2
    b = [1,0]

    Result: 1024

    https://leetcode.com/problems/super-pow/

\end{lstlisting}

\textbf{Solution 1}

~~ Fast Exponentiation is one solution, just aware of using high-precision solution to deal with the div 2 calculation. And, remember to mod 1337 everywhere.

\javacode{Pro372_1}{Solution 1 - Fast Exponentiation}

\textbf{Solution 2}

~~ I didn't get the solution... Copy the solution here, for future inspiration.

~~  The main idea is cashed on the repeated pattern of the remainder of $a^b$.

~~  As long as we know the length of the pattern m, we just have to find an index point of this pattern based on b mod m.

~~~  In addition, if a $>$ 1337, we can let a = a mod 1337.

~~~  Because if we let a = (1337x + c) where c = a mod 1337,

~~~  (1337x + c)(1337x + c)(1337x + c)...(1337x + c) mod 1337 == ccc...c mod 1337.

~~~~ It iterates at most 1337 times to find the circle. And find the remainder to the loop size. And then look up in the history to find the final answer.

\javacode{Pro372_2}{Solution 2 - the Remainder Repeat Pattern}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 386 Lexicographical Numbers
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 386 Lexicographical Numbers}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given an integer n, return 1 - n in lexicographical order.

    For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].

    Please optimize your algorithm to use less time and space.
     The input size may be as large as 5,000,000.

    https://leetcode.com/problems/lexicographical-numbers/

\end{lstlisting}

\textbf{Solution 1}

~~ Just a dfs problem, not difficult at all. However, optimization on the way.

\javacode{Pro386_1}{Solution 1 - DFS}

\textbf{Solution 2}

~~ To be continued... Needs optimization.

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 347 Top K Frequent Elements
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 347 Top K Frequent Elements}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a non-empty array of integers, return the k most frequent elements.

    For example,
    Given [1,1,1,2,2,3] and k = 2, return [1,2].

    Note:
    You may assume k is always valid, 1 <= k <= number of unique elements.
    Your algorithm's time complexity must be better than O(n log n),
     where n is the array's size.

    https://leetcode.com/problems/top-k-frequent-elements/

\end{lstlisting}

\textbf{Solution}

~~ For $O(n logn)$, heap sort, merge sort and quick sort come into mind. When PriorityQueue provide us with built-in heap sort, we use it to solve the problem.

\javacode{Pro347}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 388 Longest Absolute File Path
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 388 Longest Absolute File Path}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Suppose we abstract our file system by a string in the following manner:

    The string "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext" represents:

    dir
        subdir1
        subdir2
            file.ext
    The directory dir contains an empty sub-directory subdir1
     and a sub-directory subdir2 containing a file file.ext.

    The string
     "dir\n\tsubdir1\n\t\tfile1.ext\n\t
     \tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"
      represents:

    dir
        subdir1
            file1.ext
            subsubdir1
        subdir2
            subsubdir2
                file2.ext
    The directory dir contains two sub-directories subdir1 and subdir2.
     subdir1 contains a file file1.ext and
      an empty second-level sub-directory subsubdir1.
       subdir2 contains a second-level sub-directory subsubdir2 containing
        a file file2.ext.

    We are interested in finding the longest (number of characters) absolute path
     to a file within our file system.
      For example, in the second example above,
       the longest absolute path is "dir/subdir2/subsubdir2/file2.ext",
        and its length is 32 (not including the double quotes).

    Given a string representing the file system in the above format,
     return the length of the longest absolute path to file
      in the abstracted file system. If there is no file in the system, return 0.

    Note:
    The name of a file contains at least a . and an extension.
    The name of a directory or sub-directory will not contain a ..
    Time complexity required: O(n) where n is the size of the input string.

    Notice that a/aa/aaa/file1.txt is not the longest file path,
     if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png.

    https://leetcode.com/problems/longest-absolute-file-path/

\end{lstlisting}

\textbf{Solution}

~~ Used number of `$\backslash$t' as array index, a 1D array is enough to store the value since the structure is like a tree.

\javacode{Pro388}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 354 Russian Doll Envelopes
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 354 Russian Doll Envelopes}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    You have a number of envelopes with widths and heights given as
     a pair of integers (w, h).
      One envelope can fit into another if and only if
       both the width and height of one envelope
        is greater than the width and height of the other envelope.

    What is the maximum number of envelopes can you Russian doll?
     (put one inside other)

    Example:
    Given envelopes = [[5,4],[6,4],[6,7],[2,3]],
     the maximum number of envelopes you can Russian doll is
      3 ([2,3] => [5,4] => [6,7]).

    https://leetcode.com/problems/russian-doll-envelopes/

\end{lstlisting}

\textbf{Solution}

~~ A very interesting problem. First, sort the envelopes according to no matter width or height, let's say width, when 2 envelopes are of the same width, put the one with larger height in the front. Then the problem is converted to `Longest Increasing Subsequence'(and now we know why we put larger ones in front, since envelopes with same width cannot enclose each other, we use the sequence of larger $->$ smaller to avoid enclosing envelopes with same width). For `Longest Increasing Subsequence', there is a $O(n^2)$ DP solution and $O(n logn)$ Binary Search solution.

\javacode{Pro354}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 389 Find the Difference
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 389 Find the Difference}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given two strings s and t which consist of only lowercase letters.
    String t is generated by random shuffling string s and
     then add one more letter at a random position.
    Find the letter that was added in t.
    Example:
    Input:
    s = "abcd"
    t = "abcde"

    Output:
    e

    Explanation:
    'e' is the letter that was added.

    https://leetcode.com/problems/find-the-difference/

\end{lstlisting}

\textbf{Solution - Array}

~~ Quite an easy problem. However, there are still some interesting things in it. First is a plain solution with array.

\javacode{Pro389_1}{Solution 1}

\textbf{Solution - Bit manipulation}

~~ Can you still remember `Single Number' series? Can you find it similar between that series and this one?

\javacode{Pro389_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 382 Linked List Random Node
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 382 Linked List Random Node}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a singly linked list, return a random node's value from the linked list.
     Each node must have the same probability of being chosen.

    Follow up:
    What if the linked list is extremely large and its length is unknown to you?
     Could you solve this efficiently without using extra space?

    Example:
        // Init a singly linked list [1,2,3].
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        Solution solution = new Solution(head);

        // getRandom() should return either 1, 2, or 3 randomly.
        Each element should have equal probability of returning.
        solution.getRandom();

    https://leetcode.com/problems/linked-list-random-node/

\end{lstlisting}

\textbf{Solution - Regular and Follow-up}

~~ For this problem, the solution at first sight is to calculate the length of data stream(number of elements inside stream) and get random number based on that. So the code seems like this:

\javacode{Pro382_1}{Solution 1}

~~\textbf{HOWEVER!} When the stream is extremely large so that we are not able to put it into memory, we need to refer to some other solutions. Here is the option, the Reservoir Sampling.\\

~~ Here comes the references, for Chinese version, visit

~~~~ \url{http://blog.jobbole.com/42550/}

~~ And for English version, visit

~~~~ \url{http://blog.cloudera.com/blog/2013/04/hadoop-stratified-randosampling-algorithm/}\\

~~ The main thought is to preserve only one number, e.g.: when 1,2,3 comes from stream:

~~~~When only 1 comes, it is definitely 100\% picked;

~~~~1, 2 come, both have 1/2=50\% probability to be picked out, in other words, the number has 1/2 probability to be changed from 1 to 2;

~~~~Next the 3. We give it 1/3 probability to be chosen to substitute whatever we have stored, 1 or 2. Then how about the chance for 1 and 2 to be replaced? 2/3(not substituted by 3)*1/2(chosen at previous step)

~~~~....

~~~~ For controlling the chance to 1/n, we use $ n == new Random().nextInt(n + 1)$

\javacode{Pro382_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 352 Data Stream as Disjoint Intervals
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 352 Data Stream as Disjoint Intervals}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a data stream input of non-negative integers a1, a2, ..., an, ...,
     summarize the numbers seen so far as a list of disjoint intervals.

    For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ...,
     then the summary will be:
    [1, 1]
    [1, 1], [3, 3]
    [1, 1], [3, 3], [7, 7]
    [1, 3], [7, 7]
    [1, 3], [6, 7]

    Follow up:
    What if there are lots of merges and the number of disjoint intervals
     are small compared to the data stream's size?

    https://leetcode.com/problems/data-stream-as-disjoint-intervals/

\end{lstlisting}

\textbf{Solution - At first sight}

~~Use binary search to find the correct insertion position, then do the insertion or merge(there are conditions when number already exists, can be merged into two Intervals, can be merged into one side or create a new Interval(maybe at the very beginning, in the middle or in the end), which forms the difficulty of the problem).

\javacode{Pro352_1}{Solution 1}

\textbf{Solution - Follow-up}

~~To be continued...

\javacode{Pro352_2}{Solution 2}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 363 Max Sum of Rectangle No Larger Than K
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 363 Max Sum of Rectangle No Larger Than K}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a non-empty 2D matrix matrix and an integer k,
     find the max sum of a rectangle in the matrix
      such that its sum is no larger than k.

    Example:
    Given matrix = [
      [1,  0, 1],
      [0, -2, 3]
    ]
    k = 2

    The answer is 2.
     Because the sum of rectangle [[0, 1], [-2, 3]] is 2
      and 2 is the max number no larger than k (k = 2).

    Note:
    The rectangle inside the matrix must have an area > 0.
    What if the number of rows is much larger than the number of columns?

    https://leetcode.com/problems/max-sum-of-sub-matrix-no-larger-than-k/

\end{lstlisting}

\textbf{Solution}

~~ Though it's a bit difficult, I think it is interesting and worth thinking. The solution makes use of TreeSet to find sum in range.

~~ First for simplification, we think of the 1D solution. It's not that difficult. DP tells us that when referring to sum[i to j], what we only need is sum[j] - sum[i - 1](remember to check boundary). Then, we need TreeSet(BST, to be more specific) to store each sum, and when a new sum comes, compare it with older sums to satisfy sum[curIdx] - sum[formerIdx] $<=$ k, namely sum[curIdx] = treeSet.floor(sum[formerIdx] + k).

~~ As for the 2D part, it's still in DP vision. Remember what we have done in Problem 85 `Maximal Rectangle'? We just use similar thoughts with that problem and what we used in this problem to get sums for each column based on their row index. Then, apply the 1D solution on each row.

~~ A thing is that the test cases are special, they match the 2nd Note in description that the number of rows is much larger than the number of columns? That's why you can find in the solution below that the calculation process seems a bit weird while the code commented seems more normal.(The `normal' code costs 800ms to solve a case when `weird' one is solving the same in 100ms). Honestly, I think that's what shouldn't be happening.

\javacode{Pro363}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 384 Shuffle an Array
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 384 Shuffle an Array}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]
    Shuffle a set of numbers without duplicates.

    Example:
    // Init an array with set 1, 2, and 3.
    int[] nums = {1,2,3};
    Solution solution = new Solution(nums);

    // Shuffle the array [1,2,3] and return its result.
     Any permutation of [1,2,3] must equally likely to be returned.
    solution.shuffle();

    // Resets the array back to its original configuration [1,2,3].
    solution.reset();

    // Returns the random shuffling of array [1,2,3].
    solution.shuffle();

    https://leetcode.com/problems/shuffle-an-array/

\end{lstlisting}

\textbf{Solution}

~~ Using ``Knuth Shuffle''(or to be more specific, the FisherYates shuffle since they are the real ones who invent this).

~~ For reference: \url{https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle}

~~The thought is simple, for number at index i, generate random integer between [0,i](using rand.nextInt()), and swap numbers at index i and random number.

~~ Note that this kind of shuffle is not in a uniform probability distribution and making it evenly spread is not difficult, just change the [0,i] into [0,len].

\javacode{Pro384}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 380 Insert Delete GetRandom O(1)
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 380 Insert Delete GetRandom O(1)}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Design a data structure that supports all following operations
     in AVERAGE O(1) time.

        insert(val): Inserts an item val to the set if not already present.
        remove(val): Removes an item val from the set if present.
        getRandom: Returns a random element from current set of elements.
         Each element must have the same probability of being returned.

    Example:
        // Init an empty set.
        RandomizedSet randomSet = new RandomizedSet();

        // Inserts 1 to the set. Returns true as 1 was inserted successfully.
        randomSet.insert(1);

        // Returns false as 2 does not exist in the set.
        randomSet.remove(2);

        // Inserts 2 to the set, returns true. Set now contains [1,2].
        randomSet.insert(2);

        // getRandom should return either 1 or 2 randomly.
        randomSet.getRandom();

        // Removes 1 from the set, returns true. Set now contains [2].
        randomSet.remove(1);

        // 2 was already in the set, so return false.
        randomSet.insert(2);

        // Since 1 is the only number in the set, getRandom always return 1.
        randomSet.getRandom();

    https://leetcode.com/problems/insert-delete-getrandom-o1/

\end{lstlisting}

\textbf{Solution}

~~ Actually a smart problem. For an O(1) insert and remove operation, it's quite hard to find a data single structure to satisfy both. Array is in O(1) insert but remove needs more time(since we have to put elements behind the deleted one into proper position, namely move forward for 1 index). So wait! We were using the word `behind'! What if the element is just at the end of array? So that's the core thinking of our solution, when we want to remove an element, swap it with the last element in array(when we need to support checking existence in array, an extra HashMap is needed), remove it and maintain the actual size.

~~ The solution is not even the most interesting part. We can see there is a word `average' in problem description which is actually not in the 1st version of it. This is related to a discussion here.

\url{https://discuss.leetcode.com/topic/53193/are-hash-tables-ok-here-they-re-not-really-o-1-are-they}

~~ Main conflict is that actually, Hashtables(Map/Set) are not O(1) in inserting and removing, actually they are \textbf{amortized} O(1)(because of the array expansion and removal issues). Detailed discussion can be found in url above, which is quite interesting, I think.

\javacode{Pro380}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 381 Insert Delete GetRandom O(1) - Duplicates allowed
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 381 Insert Delete GetRandom O(1) - Duplicates allowed}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Design a data structure that supports all following operations
     in average O(1) time.
    Note: Duplicate elements are allowed.

    insert(val): Inserts an item val to the collection.
    remove(val): Removes an item val from the collection if present.
    getRandom: Returns a random element from current collection of elements.
     The probability of each element being returned is linearly
      related to the number of same value the collection contains.

        Example:
        // Init an empty collection.
        RandomizedCollection collection = new RandomizedCollection();

        // Inserts 1 to the collection.
        // Returns true as the collection did not contain 1.
        collection.insert(1);

        // Inserts another 1 to the collection.
        // Returns false as the collection contained 1. Collection now contains [1,1].
        collection.insert(1);

        // Inserts 2 to the collection, returns true.
        // Collection now contains [1,1,2].
        collection.insert(2);

        // getRandom should return 1 with the probability 2/3,
        // and returns 2 with the probability 1/3.
        collection.getRandom();

        // Removes 1 from the collection, returns true.
        // Collection now contains [1,2].
        collection.remove(1);

        // getRandom should return 1 and 2 both equally likely.
        collection.getRandom();

    https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/

\end{lstlisting}

\textbf{Solution}

~~ Not so different as the previous Problem ``Insert Delete GetRandom O(1)''. Largest difference may lies in the fact that we now need a Set rather than just a number to preserve the positions of each elements; Pick the last occurrence of element will save a few effort; Don't forget to maintain the remaining position information as long as don't forgetting to remove when no such elements exists.

\javacode{Pro381}{Solution}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 385 Mini Parser
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 385 Mini Parser}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given a nested list of integers represented as a string,
     implement a parser to deserialize it.
    Each element is either an integer, or a list
     -- whose elements may also be integers or other lists.

    Note: You may assume that the string is well-formed:
        String is non-empty.
        String does not contain white spaces.
        String contains only digits 0-9, [, - ,, ].

    Example 1:
    Given s = "324",

    You should return a NestedInteger object which contains a single integer 324.

    Example 2:
    Given s = "[123,[456,[789]]]",

    Return a NestedInteger object containing a nested list with 2 elements:

    1. An integer containing value 123.
    2. A nested list containing two elements:
        i.  An integer containing value 456.
        ii. A nested list with one element:
             a. An integer containing value 789.

    https://leetcode.com/problems/mini-parser/

\end{lstlisting}

\textbf{Solution}

~~ A typical recursive/stack problem, however I was struggling with it for a long time(Actually, I'm still struggling). The train of thought is not difficult, just split the string, use a counter to check whether the brackets are in pairs, if yes, then the comma `,' shall be the splitter.

~~ Two kinds of solutions are listed as below, one recursive and one iterative using stack.

\javacode{Pro385_1}{Solution - Recursion}

\javacode{Pro385_2}{Solution - Stack}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 391 Perfect Rectangle
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\title{\textbf{\large 391 Perfect Rectangle}}


\begin{lstlisting}[language=tex,stepnumber=100,frame=shadowbox]

    Given N axis-aligned rectangles where N > 0,
     determine if they all together form an exact cover of a rectangular region.
    Each rectangle is represented as a bottom-left point and a top-right point.
     For example, a unit square is represented as [1,1,2,2].
      (coordinate of bottom-left point is (1, 1) and top-right point is (2, 2)).

    Example 1:
    rectangles = [
      [1,1,3,3],
      [3,1,4,2],
      [3,2,4,4],
      [1,3,2,4],
      [2,3,3,4]
    ]

    Return true. All 5 rectangles together
     form an exact cover of a rectangular region.



    Example 2:
    rectangles = [
      [1,1,2,3],
      [1,3,2,4],
      [3,1,4,2],
      [3,2,4,4]
    ]

    Return false. Because there is a gap between the two rectangular regions.



    Example 3:
    rectangles = [
      [1,1,3,3],
      [3,1,4,2],
      [1,3,2,4],
      [3,2,4,4]
    ]

    Return false. Because there is a gap in the top center.



    Example 4:
    rectangles = [
      [1,1,3,3],
      [3,1,4,2],
      [1,3,2,4],
      [2,2,4,4]
    ]

    Return false. Because two of the rectangles overlap with each other.

    https://leetcode.com/problems/mini-parser/

\end{lstlisting}

~~ First let me add the demonstration figures for a better visualization.

~~\includegraphics[width=0.2\columnwidth]{figures/391_perfect_rectangle_1}
~~\includegraphics[width=0.2\columnwidth]{figures/391_perfect_rectangle_2}
~~\includegraphics[width=0.2\columnwidth]{figures/391_perfect_rectangle_3}

\textbf{Solution - Sweep line}

~~ First solution makes use of a standard geometric search algorithm - sweep line. Basically sort blocks by x-axis $->$ put or remove y-axis values into or from TreeSet for range search $->$ find the overlaps. There are small tricks for better performance like bit manipulation. Screenshot of detailed description of algorithm is as below.

~~\includegraphics[width=0.75\columnwidth]{figures/391_perfect_rectangle_4}

\javacode{Pro391_1}{Solution - Sweep line}

\textbf{Solution - Tricks}

~~\includegraphics[width=0.75\columnwidth]{figures/391_perfect_rectangle_5}

~~\\

~~ This solution description is copied from the hottest topic in Discuss forum for this problem. Actually, there is an easier trick which can solve the problem. There are blue, green and red dots inside graph, an interesting fact is, if they want to form a perfect rectangle, they should follow 2 rules: 1. the total area should be exactly the same as $(max_y - min_y)*(max_x - min_x)$; 2. \textbf{There are four and only four corner points which appears once}(namely the blue points). 

~~ So we just add every corner points of each rectangle into a set, if it exists, remove it(to remove those points in pairs). Finally, we check 1. the total area; 2. whether the size points remaining is exactly four and are the min and max points.

\javacode{Pro391_2}{Solution - tricks}

\end{homeworkProblem}
\newpage

%----------------------------------------------------------------------------------------

\end{document}
